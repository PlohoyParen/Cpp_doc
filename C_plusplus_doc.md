# Ouline
1. [**Chapter 1: General**](#chapter-1-general)     
	- Понятия и термины    
	- General structure  
		- Вид типичного ситаксиса   
		- Общий цикл написания программы       

2. [**Chapter 2: Operators**](#chapter-2-operators)     
	- Assiment and initialisation    
	- Оператор запятая (,)    
	- Тернарный if     
	- Math    
		- Общее 
		- cmath
		- random number generator 
	- library <algorithm>
		
3. [**Chapter 3: Streams**](#chapter-3-streams)   
	- std::cin
	- std::cout

4. [**Chapter 4: Memory**](#chapter-4-memory)
	- Pointers
		-
		-
	- References
	
	- Dynamic memory allocation
		- bad_alloc
		- Memory leak
		

5. [**Chapter 5: Data types**](#chapter-5-data-types)
	- Встроенные типы
	- char
	- Фиксированный размер int
	- float/double: ошибки округления
	- nan и inf
	- constants
	- Преобразование типов
	- typedef (alias)
	- library needed
		- String 
		- Vector
		- Map
	- Arrays (Массивы)
		- Regular arrays(фиксированные массивы)
		- C-style strings
		- Dynamic arrays(Динамические массивы)
	- User-defined data types
		- Enumeration (enum) type
		- Struct (public class)
	 	- Helpful functions
	
6. [**Chapter 6: Control Flow**](#chapter-6-control-flow)
	- Branches (Ветвление)
		- is else
		- Switch
 	- loops
		- for
		- while, while do

7. [**Chapter 7: Functions**](#chapter-7-functions)
	- Общее, main, void
	- Прототип функции
	- Аргументы

8. [**Chapter 8: Files and project magement**](#chapter-8-files-and-project-magement)
	- Добавление файла в проект
	- header file (.h)
	- Директивы препроцессора
	- header guards
	
9. [**Chapter 9: Scopes**](#chapter-9-scopes)
	- Scopes (Зоны видимости)
		- Локальные переменные, глобальные переменные (static, extern) 
		- сокрытие имен, глобальные ф-ции
	- namespace
		- Глобальное пространство имен 
		- :: и using
		- Псевдонимы (вложение)
		
10. [**Chapter 10: Other**](#chapter-10-other)
	- Использование слова static 

---

# Chapter 1 General 

## Понятия и термины
- **Integral data type** - типы данных основанных на целых числах (char, short, int, long, long long, enum). 
- **Блок стейтментов** (или ещё **«составной оператор»**) обрабатывается компилятором так, как если бы это был один стейтмент. Составные операторы помещаются в фигурные скобки ({ и }) и используются почти везде. Блок ({}) может выделять локальные области сам по себе (т.е. не являясь частью ф-ции).
- **Литеральные константы** (или просто **«литералы»**) — это значения, которые вставляются непосредственно в код (напр., 3.141 - это литерал типа float, 'A' - это литерал типа char. Т.е. литерал чистай все что угодно в коде(?))   
- **Магические числа (magic numbers)** - числа, которые встречаются в коде без пояснения и непонятно что они делают. Это делает код нечитаемым. Поэтому лучше всегда присвоить значение переменной с ясным названием, чем использовать голые числа.   

- **Время компиляции**: когда вы находитесь в процессе компиляции программы, то это время компиляции (англ. «compile time»). Компилятор проверяет вашу программу на синтаксические ошибки и, если их нет, конвертирует код в объектные файлы. **Константы времени компиляции**: их значения определяются во время компиляции программы. Например, переменная, значение которой было задано до с самого начала.   
- **Время выполнения**: когда вы находитесь в процессе запуска вашей программы или когда ваша программа уже выполняется, то это время выполнения (англ. «runtime»). Код выполняется строка за строкой. **Константы времени выполнения**: их значения определяются только во время выполнения программы (например, если пользаватель вводит данные через cin или программа сама высчитывает какое-то значение.     

- Переменные с **автоматической продолжительностью** создаются в точке определения и уничтожаются при выходе из блока, в котором определены. Это - обычные локальные переменные.   
- Переменные со **статической продолжительностью** создаются, когда программа запускается, и уничтожаются при её завершении. Это - глобальные переменные, статические локальные переменные.   
- Переменные с **динамической продолжительностью** создаются и уничтожаются по запросу программиста.   

- **Статическое выделение памяти** выполняется для статических и глобальных переменных. Память выделяется один раз, при запуске программы, и сохраняется на протяжении работы всей программы.
- **Автоматическое выделение памяти** выполняется для параметров функции и локальных переменных. Память выделяется при входе в блок, в котором находятся эти переменные, и удаляется при выходе из него.    
В обих случаях (1 и 2) память выделяется из **стека (stack)**. Его рамер зависит от компилятора, но всегда очень мал (порядка 1-2 МБ).
- **Динамическое выделение памяти** - это способ запроса памяти из операционной системы запущенными программами по надобности. Эта память не выделяется из ограниченной памяти стека программы, а из гораздо большего хранилища, управляемого операционной системой — **кучи** (порядка n-Гб).     


  
## General structure
```cpp
#include <iostream>
using namespace std;

int x;                              //global variables
int z = 4;

int main() {
    x = 2;          
    int y = 3;                      //local variable (хотя и для main)
    cout << "Size of int: " << sizeof(int) << endl;  
    cout << (x - y)*z;
    return 0;
}
```
### Общий цикл написания программы
1. Пишем код в соответствии синтаксису. Сохраняем в формате *name.cpp*.
2. Компилятор: преобразует команды С++ в объектный файл (*.o*, машинный код). Из *name.cpp* создается *name.o* (или *name.obj*). Каждый файл *.cpp* конвертируется в свой *.o*. (Пока они не связаны).  Если в системе стоит компилятор, то из консоли можно это сделать (`-c`): `g++ -c file1.cpp file2.cpp file3.cpp`.
3. Линкер ("компоновщик"): объектные файлы и вызовы библиотек связываются в исполняемый файл (один). Т.е. этого момента все файлы и библиотеки не видят друг друга, во время компановки они начинают взаимодействовать (передавать ф-ции и тд). На этом этапе происходит ошибка, если переменная или функция была объявлена, но не определена. Из консоли можно это сделать (`-o`): `g++ -o prog file1.o file2.o file3.o` (если из уже скомпилированы) или `g++ -o prog file1.cpp file2.cpp file3.cpp` (если еще не скомпилированы).

---

# Chapter 2 Operators

## Assiment and initialisation
1. Есть в C++ все переменные являются **l-values**, т.е. стоят слева от оператора присвоения. L-values имеют ячейку в памяти (и адрес), куда записываются значения. **r-value** (спарава) — это значение, которое не имеет постоянного адреса в памяти. Так числа не имеют места в памяти. Например:  
```cpp
int a=5;  	
a = 4 + 6;	// в обоих случая a - l-value

int b;		// тут b - это l-value
b = a;		// тут b - l-value, a - r-value (не переменная, а число 10) т.е. это тоже самое что просто `b = 10;`
b = b + 2;	// тут b и l-value (слева) и r-value(справа): `b = 10 + 2;`
```
2. При **объявлении (declare)** переменной ей присваивается некоторая ячейка памяти (определенного рамеза, в зависимости от типа данных). При **присваивании (assigment)** происходит полное копирование объекта. **Инициаллизация (initialization)** - это объявление и присвоение за раз.
```cpp
vector<int> x = {1,2,3,4}	//Инициализация
vector<int> y;                  //Объявление
y = x                           /*Присвоение. Создаст новую копию (выделит место в памяти). 
                                Т.е. будет 2 независимых вектора x и y, а не 2 указателя на 1 объект как в python */
```
3. Есть 3 типа инициализации:
	1. `int nValue = 5; // копирующая инициализация` - работает не со всеми типами данных 
	2. `int nValue(5);  // прямая инициализация` - работает не со всеми типами данных 
	3. `int value{5};   // uniform инициализация` - - работает со всеми типами данных (начиная с C++ 11). `int value{}; // инициализация переменной по умолчанию - нулём`.  
```cpp
double d(5.0); // 5.0 - это тип данных с плавающей точкой (по умолчанию double)
float f(5.0f); // 5.0 - это тип данных с плавающей точкой, "f" от "float"
```
4. присваивание - только копирующее `int nValue; nValue = 5; // копирующее присваивание`   
5. Для нескольких переменных разом:   
```cpp
int x, y;		// объявление нескольких переменных разом (только для перемен. одного типа)
int a = 5, b = 6;	// инициализация нескольких переменных разом 
int c(7), d(8);		// (всеми 3мя способами)
int e{9}, f{10};
// смешаный случай (можно, но не рекомендуется)
int a, b(5); 		// значение 5 присваивается только переменным b и d.
int c, d{5};
```    
6. **Правило:** Определяйте переменные как можно ближе к их первому использованию:
```cpp
int main()
{
    std::cout << "Enter a number: ";
    int x; // мы используем x в следующей строке, поэтому объявляем эту переменную здесь: как можно ближе к её первому использованию
    std::cin >> x; // первое использование переменной x
 
    std::cout << "Enter another number: ";
    int y; // переменная y понадобилась нам только здесь, поэтому здесь её и объявляем 
    std::cin >> y; // первое использование переменной y
 
    std::cout << "The sum is: " << x + y << std::endl;
    return 0;
}
```
Это улучшает читаемость: сразу понятно где и для чего нужна переменная, не надо держать ее в голове до первой встречи и т.д.

## Оператор запятая (,)
`x, y` - Вычисляется x, затем вычисляется y, а затем возвращается значение y. (Зачем он нужен - неясно, т.к. читается он плохо).
```cpp
z = a, b; // вычисляется как "(z = a), b", поэтому переменной z присваивается значение a, а переменная b игнорируется
```

## Тернарный if 
`c ? x : y` - Если c — ненулевое значение (true), то вычисляется x, в противном случае — y (**(условие) ? выражение : другое_выражение;**). Нужен для коротких выражений if else
```cpp
if (x > y)
    std::cout << x;
else
    std::cout << y;
  
// тоже самое 

larger = (x > y) ? x : y;
```
Или так:
```cpp
bool inBigClassroom = false;
const int classSize = inBigClassroom ? 30 : 20;  // если false, то 30, если true 20
```

## Math
1. Экспоненциальная запись: 1.2 x 10^4 эквивалентно `1.2e4`
2. i++, ++i - инкременты. `int x = ++y` присвоит (y+1) (считается более безопасным). `int x = y++` сначала присвоит y, а потом прибавит 1. 
   i--, --i - декрименты
3. Деление: `int x, y; x/y` вернет целочисленное деление, если оба int. Если любой из них float/double, то вернет обычное деление.
`x%y` - остаток от деления.
4. Логика: не `!a`, и `&&`, или `||`
5. 8-ричная, 16-ричная сисемы и бинарная (с С++ 14):
```cpp
int x = 012; // 0 перед значением означает, что это восьмеричный литерал
int x = 0xF; // 0x перед значением означает, что это шестнадцатеричный литерал
// Начиная с С++ 14 бинарная
bin = 0b11; // присваиваем переменной бинарный литерал 0000 0011 
bin = 0b1010; // присваиваем переменной бинарный литерал 0000 1010
```

### cmath
`# include <cmath>`   
- `pow(x, power)` x^power. Принимает и ворварщает тип double. 

### random number generator
#### Хороший генератор последовательности случайных чисел (ГПСЧ)
Т.к комньютер не способен генерировать случайные числа, то все ГПСЧ работают по принципу: 1) берем какое то начальное значение (seed), а потом последовательно проводим операции над ним. Если опреции подобраны хорошо, то они будут производить псеводо случайные числа. Однако, у это последовательности есть логика (которую можно взломать) и переод генерации (это значит, что через сколько-то чисел все пойдет по кругу, и последовательность повторит саму себя). Хороший ГПСЧ обладает свойствами:    

1. ГПСЧ должен генерировать каждое новое число с примерно одинаковой вероятностью. Это называется **равномерностью распределения**.
2. Метод, с помощью которого генерируется следующее число в последовательности, не должен быть очевиден или предсказуем.
3. ГПСЧ должен иметь хорошее диапазонное распределение чисел. Это означает, что маленькие, средние и большие числа должны возвращаться случайным образом
4. Хороший ГПСЧ должен иметь длинный период для любых стартовых чисел (seed). Бывают ГПСЧ, которые имеют разный период и неравномерно распределяют СЧ в зависимости от seed. 

#### Типы ГПСЧ доступные в C++
1. `#include <cstdlib>` - простой ГПСЧ.
- `srand(4541)` - создает зерно для генирации случайных чисел (СЧ). В качетсве seed часто ставят системные часы с помощью ф-ции `time()`, которая возвращает в качестве времени общее количество секунд от полуночи 1 января 1970 года. Например,   
```cpp
// устанавливаем значение системных часов в качестве стартового числа
#include <ctime> // для функции time()
#include <cstdlib> // для функций rand() и srand()
srand(static_cast<unsigned int>(time(0)));
```

- `rand()` - создает СЧ с помощью Линейного Конгруэнтного Метода (или ещё «ЛКМ»).     
Это довольно посредственный ГПСЧ т.к. 1) имеет невысокий период генерации, 2) RAND_MAX (максимум длинны) обычно устанавливается как 32 767 (15-битное значение), 3) генерирует только int.      
**Генерачия СЧ в определенном диапозоне**
```cpp
// Генерируем рандомное число между значениями min и max
// Предполагается, что функцию srand() уже вызывали
int getRandomNumber(int min, int max)
{
    static const double fraction = 1.0 / (static_cast<double>(RAND_MAX) + 1.0); 
    // Равномерно распределяем рандомное число в нашем диапазоне
    return static_cast<int>(rand() * fraction * (max - min + 1) + min);
}
```

2. `#include <random>` - позволяет использовать более продвинутые ГПСЧ, такие как Вихрь Мерсенна и другие
```cpp
#include <iostream>
// #include <ctime> // раскомментируйте, если используете Code::Blocks
#include <random> // для std::random_device и std::mt19937
 
int main()
{
    std::random_device rd; 
    std::mt19937 mersenne(rd()); // инициализируем Вихрь Мерсенна случайным стартовым числом 
 
// Примечание: Из-за одного бага в компиляторе Code::Blocks (если вы используете Code::Blocks в Windows) - удалите две строчки кода выше и раскомментируйте следующую строчку:
// std::mt19937 mersenne(static_cast<unsigned int>(time(0))); // инициализируем Вихрь Мерсенна случайным стартовым числом
 
    // Выводим несколько случайных чисел
    for (int count = 0; count < 48; ++count)
    {
        std::cout << mersenne() << "\t";
 
        // Если вывели 5 чисел, то вставляем символ новой строки
        if ((count + 1) % 5 == 0)
            std::cout << "\n";
    }
}
```
## library "algorithm"
1. `count(begin, end, what)` - считает *what* в любом контейнере (string, array etc):
    ```cpp
    #include <algorithm>
    vector<int> nums= {1,2,3, 5, 6,43, 5};
    int quantity = count(begin(nums), end(nums), 5);
    cout << qunantity;         //will return 2
    ```
2. `sort(begin, end)` - сортировка любого контейнера (string, array etc). The algorithm used by sort() is *IntroSort*. Introsort being a hybrid sorting algorithm uses three sorting algorithm to minimise the running time, *Quicksort*, *Heapsort* and *Insertion Sort*, taking the fastest fot the case. Comlexity: O(N*log(N)).
    ```cpp
    #include <algorithm>
    sort(begin(nums), end(nums))
    ```
3. `swap(a, b)` - меняем местами значения переменных a и b (напр., a=1, b=2 -> a=2, b=1)

---

# Chapter 3 Streams 

## Streams
### std::cin
`cin >> ..` - поток ввода. Из буфера в переменую сохраняется только соответсвующая переменной часть (т.е. для int - число до пробела, для char - один символ и тд). Остальная часть пользовательского ввода останется во входном буфере, который использует cin и будет доступна для использования последующим вызовам cin (`cin << a << b << c;` a, b, c - три раза вызов cin).

#### Обработка некорректного ввода
При некорректном вводе (переполнение или неправельный тип принимающией переменной), надо очистить буфер:
```cpp
// при некорректном вводе, отчистит буфер
if (std::cin.fail()) 		 // если предыдущее извлечение не выполнилось или произошло переполнение,
{
    std::cin.clear(); 		 // то возвращаем cin в 'обычный' режим работы
    std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
}
else 
    return a;			 // В случаи, что проблем нет возращаем введенные данные
```
Можно сделать `while(true){}`, где принимать `std::cin >> a;`, а затем проводить тест используя кусок кода выше. Тогда, если все ОК то данные пройдут, если не ОК, то буфер отчистится и пользователь введет данные еще раз.

### std::cout
`cout << endl;` - после вывода переведет на новую строку  

**Precision**
`std::setprecision(number);` 	
```cpp
#include <iostream>
#include <iomanip>					 // для std::setprecision()
std::cout << std::setprecision(16); 			 // задаём точность в 16 цифр
float f = 3.33333333333333333333333333333333333333f;     // выдаст 3.333333253860474
std::cout << f << std::endl;
double d = 3.3333333333333333333333333333333333333;	// выдаст 3.333333333333333
std::cout << d << std::endl;
```
Точность по типам данных: 
-float: от 6 до 9 цифр (в основном 7);
-double: от 15 до 18 цифр (в основном 16);
-long double: 15, 18 или 33 цифры;      
(Точность типа данных - *лимитирующий фактор*: округляется все по типу данных, а не точности вывода. Так, если float имеет 7 цифр, то cout до 9 цифр выведет первые 7 правильно, а потом фигню)  

**bool**
`std::cout << std::boolalpha; // выводит логические значения как "true" или "false"`

**std::endl**
Конец и перевод строки. Прежде чем закончить строку проверяет выведены ли все данные из буфера вывода, в отличии от `\n`, который просто переводит строку (не проверяе ничего).

#### std::cout перобразование
При передаче указателя *не* типа `char`, в результате выводится просто содержимое этого указателя (адрес памяти). Однако, если вы передадите объект типа `char*` или `const char*`, то `std::cout` предположит, что вы намереваетесь вывести строку. Следовательно, вместо вывода значения указателя — выведется строка, на которую тот указывает:
```cpp
int nArray[5] = { 9, 7, 5, 3, 1 };
char cArray[] = "Hello!";
const char *name = "John";
 
std::cout << nArray << '\n'; 	// nArray распадается в указатель типа int -> 0046FAE8 (адрес)
std::cout << cArray << '\n'; 	/* cArray распадается в указатель типа char -> Hello! (распадается, а потом
автоматически преобразует указатель назад в строку */
std::cout << name << '\n'; 	// name уже и так является указателем типа char -> John
```
В связи с этим сложно вывести адрес переменой типа char:
```cpp
char a = 'R';
std::cout << &a;	// a распадется в указатель, а потом все равно автоматически преобразуется назад.
/* выведет: R╠╠╠╠╜╡4;¿■A (т.е. литерал R, а потом мусор следующий за нем в памяти до ближайшего 0 */
```

---

# Chapter 4 Memory
При выполнении инициализации переменной, ей автоматически присваивается свободный адрес памяти, и, любое значение, которое мы присваиваем переменной, сохраняется в этом адресе памяти. Нам не надо знать сам адрес, его связку с переменной знает компилятор. Мы просто ссылаемся на переменную через присвоенный ей идентификатор, а компилятор конвертирует это имя в соответствующий адрес памяти.    
**Оператор адреса (address-of operator)** (`&`) позволяет узнать, какой адрес памяти присвоен определённой переменной (в отличии от оператора побитового И (бинарного), это унарный опертор). **Оператор разыменования (dereference operator)** (`*`) позволяет получить значение по указанному адресу (в отличии от оператора умножения (бинарного), это унарный опертор).
```cpp
int a = 7;
std::cout << a << '\n'; // выводим значение переменной a
std::cout << &a << '\n'; // выводим адрес памяти переменной a
std::cout << *&a << '\n'; /// выводим значение ячейки памяти переменной a

/*  Вывод: 7 \n  0046FCF0  \n  7  */
```

## Pointers
**Указатель (pointer)** - это переменная, значением которой является адрес (ячейка) памяти. Указатели объявляются точно так же, как и обычные переменные, только со звёздочкой между типом данных и идентификатором. Тип указателя должен соответствовать типу переменной, на которую он указывает:
```cpp
int *iPtr; // указатель на значение типа int
double *dPtr; // указатель на значение типа double
 
int* iPtr3; // корректный синтаксис (допустимый, но не желателен)
int * iPtr4; // корректный синтаксис (не делайте так)

int *iPtr5, *iPtr6; // объявляем два указателя для переменных типа int
int* iPtr3, iPtr4; // iPtr3 - это указатель на значение типа int, а iPtr4 - это обычная переменная типа int!
```
Поскольку указатели содержат только адреса, то при присваивании указателю значения — это значение должно быть адресом:
```cpp
int value = 5;
int *ptr = &value; // инициализируем ptr адресом значения переменной
 
std::cout << &value << '\n'; 	// выводим адрес значения переменной value
std::cout << ptr << '\n'; 	// выводим адрес, который хранит ptr
std::cout << *ptr << std::endl; // разыменовываем ptr (получаем значение на которое указывает ptr)

/* Вывод: 003AFCD4 \n 003AFCD4 (один и тот же адрес) /n 5 (разыменовали ptr)  */
```
C++ также не позволит вам напрямую присваивать адреса памяти указателю: `double *dPtr = 0x0012FF7C; // не ок: рассматривается как присваивание целочисленного литерала`.      

**Указатель * и &**
- Оператор адреса (&) не возвращает адрес своего операнда в качестве литерала. Вместо этого он возвращает указатель, содержащий адрес операнда (и того же типа, что и операнд). 
- `ptr` — это то же самое, что и `&value`;
- `*ptr` обрабатывается так же, как и `value`.

### Scaling (Арифметика указателей)
Если `ptr` указывает на целое число, то `ptr + 1` является адресом следующего целочисленного значения в памяти после `ptr`. `ptr - 1` — это адрес предыдущего целочисленного значения (перед `ptr`). Обратите внимание, `ptr + 1` не возвращает *следующий любой адрес* памяти, который находится сразу после `ptr`, но он возвращает адрес памяти следующего объекта, тип которого совпадает с типом значения, на которое указывает `ptr`. Если `ptr` указывает на адрес памяти целочисленного значения (размер которого 4 байта), то `ptr + 3` будет возвращать адрес памяти 3го целочисленного значения после `ptr`. Если `ptr` указывает на адрес памяти значения типа char, то `ptr + 3` будет возвращать адрес памяти третьего значения типа char после `ptr`. На этом основана индексация массивов (подробнее см. в теме про индексацию массивов)

### null pointer
Если просто объявить указатель без присвоения ему данных, то ячейка памяти будет забита мусором. С целью явно показать, что указатель не указывает ни на что было введен **null pointer**:
```cpp
int *ptr(0);  // ptr теперь нулевой указатель
 
int *ptr1; // ptr1 не инициализирован
ptr1 = 0; // ptr1 теперь нулевой указатель

//C++ 11 и страше (рекомендован т.к. способы выше могут иметь конфликт: 0 - это int или null pointer)
int *ptr = nullptr; // примечание: ptr по-прежнему остаётся указателем типа int, просто со значением null (0)
```
Null pointer можно использовать в логических ветвелениях:
```cpp
double *ptr(0);
if (ptr)
	std::cout << "ptr is pointing to a double value.";
else
	std::cout << "ptr is a null pointer.";
```
Если нужно написать функцию, которая принимает ТОЛЬКО аргумент null pointer, то надо использовать `std::nullptr_t` (#include <cstddef>)

```cpp
void doAnything(std::nullptr_t ptr)
{
    std::cout << "in doAnything()\n";
}
 
int main()
{
    doAnything(nullptr); // вызов функции doAnything с аргументом типа std::nullptr_t (и только)
}
```

### const pointers and pointers to const
1. **Указатель на константную переменную**. В этом случаи случаии указатель должен быть также константным. Иначе можно было бы присвоить новое значение переменной путем разименования указателя:
```cpp
const int value = 7;		// value - это константа
int *ptr = &value; 		// ошибка компиляции: невозможно конвертировать const int* в int*
*ptr = 8; 			// иначе могли бы изменить значение value на 8

const int value_two = 7;
const int *ptr = &value_two; 	// здесь всё ок: ptr - это неконстантный указатель, который указывает на "const int"
*ptr = 8;		 	// нельзя, мы не можем изменить константное значение
```
Однако, указатель на константное значение может указывать на неконстантную переменную. В этом случаии при вызове переменной через указатель она будет рассматриваться как константа. При вызове переменной через собственное имя она будет рассматриваться как  неконстантая.
```cpp
int value = 7;
const int *ptr = &value; // ptr указывает на "const int"
value = 8; 		 // переменная value уже не константа, если к ней получают доступ через неконстантный идентификатор
*ptr = 8;		 // ptr обрабатывает value как константу, поэтому изменение значения переменной value через ptr не допускается
```
Указателю на константное значение, который сам при этом не является константным (он просто указывает на константное значение), можно присвоить и другое значение:

```cpp
int value1 = 7;
const int *ptr = &value1; // ptr указывает на const int
 
int value2 = 8;
ptr = &value2;		 // хорошо, ptr теперь указывает на другой const int
```
**Т.е. указатель может быть изменен, но не переменная (точнее не через указатель)**

2. **Константный указатель**. В этом случаи указатель инициализируется только один раз и послу этого не может быть изменен (т.е. не может указавыть на другую переменную), но сама переменная - не константа, поэтому она может быть изменена через разименование:
```cpp
/* не может указавыть на другую переменную */
int value1 = 7;
int value2 = 8;
 
int * const ptr = &value1; 	// ок: константный указатель инициализирован адресом value1
ptr = &value2;			// не ок: после инициализации константный указатель не может быть изменён

/* переменная может быть изменена через разименование */
int value = 7;
int *const ptr = &value; // ptr всегда будет указывать на value
*ptr = 8; // ок, так как ptr указывает на тип данных (неконстантный int)
```
**Т.е. указатель не может быть изменен, но переменная может** 

3. **Констатный указатель на константную переменную**
```cpp
int value = 7;
const int *const ptr = &value;
```
**Ни указатель, ни переменная не могут быть изменены**

### Оператор доступа к членам класса через указатель (->)
При создании класса, можно присвоить ему указатель и получать доступ к членам через указатель (через заименование). При этом в C++ есть оператор доступа к члену класса через указатель (`->`), что делает чтение/написание удобнее:
```cpp
struct Man
{
    int weight;
    double height;
};
Man man;
 
// Доступ к члену осуществляется через указатель на переменную структуры Man
Man *ptr = &man;
//следующие вызовы идентичны
(*ptr).weight = 60;
ptr->weight = 60;
```

### Указатель типа void
`void *ptr` - может быть указателем на любой тип данных. Проблема в том, что он не будет знать ни тип данных своего объекта, ни его размер. Поэтому его нельзя разименовать (надо знать тип данных) и с ними нельзя выполнять арифметику (надо знать размер объекта).

### Указатель на указатель
Можно создать указатель на указатель, тогда он будет содержать адрес, где хранится адрес вложенного указателя. При его разименовании мы получим адрес вложенного указателя. При двоином раименовании мы получим значение, на которое указывает вложенный указатель: 
```cpp
int value = 7;
 
int *ptr = &value;
std::cout << *ptr << std::endl; // разыменовываем указатель, чтобы получить значение типа int 
// вывод: 7
int **ptrptr = &ptr;
std::cout << **ptrptr << std::endl;	
// вывод: 7
```
Нужно это в основном для создания массива указателей, а не его основе можно делать 2х мерный динамический массив (см. в разделе про динамические массивы).    

Можно создавать и более глубокое вложение: указатель на указатель на указатель и тд. Тройное вложение можно использовать для трех-мерных динамических массивов.


## References (ссылки)
**Ссылка** — это тип переменной в C++, который работает как псевдоним другого объекта или значения. По сути, это тот же указатель, который неявно разыменовывается при доступе к значению, на которое он указывает (под капотом ссылки реализованы с помощью указателей. 

**Иничиализация** 
Ссылки должны быть инициализированы один раз и с l-value. После присвоение, ссылке нельзя присвоить новый объект (поэтому теряется возможноть потери, как у не NULL указателя):
```cpp
int a = 7;
int &ref1 = a; // ок: a - это неконстантное l-value
 
const int b = 8;
int &ref2 = b; // не ок: b - это константное l-value (для этого нужна константная ссылка: `const int &ref = b`) 
 
int &ref3 = 4; // не ок: 4 - это r-value
```
Ссылке нельзя присвоить новую переменную:
```cpp
int value1 = 7;
int value2 = 8;
 
int &ref = value1; 	// ок: ref - теперь псевдоним для value1
ref = value2; 		/* присваиваем 8 (значение переменной value2) переменной value1. Здесь НЕ изменяется объект, на который ссылается ссылка! Теперь value1 = 8 */
```

**Ссылки использутются в случаих:**
- Как псевдонимы 
	```cpp
	int value = 7; 				// обычная переменная
	int &ref = value; 			// ссылка на переменную value

	/* Объект на который ссылаются и ссылка ведут себя одинаково */
	value = 8;			 	// value теперь 8
	ref = 9;				// value теперь 9

	std::cout << value << std::endl; 	// выведется 9
	++ref;
	std::cout << value << std::endl; 	// выведется 10

	std::cout << &value; 			// выведется 0035FE58
	std::cout << &ref;			// выведется 0035FE58
	```
	Дургой пример, это псевдоним для дилинных названий при доступе к членам классов:
	```cpp
	int &ref = other.something.value1; 	//член value1, подкласса something, класса other
	/* ref теперь может использоваться вместо other.something.value1. Слудующие действия идентичны */
	other.something.value1 = 7;
	ref = 7;
	```
- Как параметр ф-ции. Все аналогично передаче по указателю: `void changeN(int &ref)`
	
### Константные ссылки
**Ссылки на константы** или **константные ссылки** могут быть инициализированы неконстантными l-values, константными l-values и r-values (в отличии от неконстантных). 
```cpp
int a = 7;
const int &ref1 = a; // ок: a - это неконстантное l-value
 
const int b = 9;
const int &ref2 = b; // ок: b - это константное l-value
 
const int &ref3 = 5; // ок: 5 - это r-value
```
Аналогично указателям на констатные переменные, константной ссылке можно присвоить неконстантную переменную. Эту переменную можно будет менять через ее собственное имя, но не через ссылку:
```cpp
int value = 7;
const int &ref = value; // создаём константную ссылку на переменную value
 
value = 8; // ок: value - это не константа
ref = 9; // нельзя: ref - это константа
```
Главная польза от них, это передача аргумента в ф-цию как константной ссылки, тем самым запретить этой ф-ции ее менять (см. главу про ф-ции, раздел аргументы).
	
## Dymanic memory allocation 
В C++ существует 3 типа **выделения памяти (memory allocation)**:
1. **Статическое выделение памяти** выполняется для статических и глобальных переменных. Память выделяется один раз, при запуске программы, и сохраняется на протяжении работы всей программы.
2. **Автоматическое выделение памяти** выполняется для параметров функции и локальных переменных. Память выделяется при входе в блок, в котором находятся эти переменные, и удаляется при выходе из него.    
В обих случаях (1 и 2) память выделяется из **стека (stack)**. Его рамер зависит от компилятора, но всегда очень мал (порядка 1-2 МБ).
3. **Динамическое выделение памяти** - это способ запроса памяти из операционной системы запущенными программами по надобности. Эта память не выделяется из ограниченной памяти стека программы, а из гораздо большего хранилища, управляемого операционной системой — **кучи** (порядка n-Гб).    

Когда программа запущена ОС выделяет ей какой-то участок памяти. Некоторая часть используется на обработку ф-ций и пд, какая-то часть идет на переменные и прочее (т.е. 1й и 2й варианты). Однако большая часть выделенной памяти висит без использования в ожидании запроса от программы на динамическое выделение памяти. Так, объявляя динамическую переменную, мы записываем ее в кучу, и не тратим стек (и без того маленький).    

Создадим переменную выделяя динамическую память. Для этого используется оператор `new`, он возвращает ссылку (поэтому ее надо присвоить какой-нибудь переменной). Присвоение осуществляется через опертор разименования ссылки (dereference: `*`ptr):
```cpp
/* Динмаическое выделение памяти и присвоение значения этой ячейке */
int *ptr = new int; // динамически выделяем целочисленную переменную и присваиваем её адрес ptr, чтобы потом иметь доступ к ней
*ptr = 8; // присваиваем значение 8 только что выделенной памяти
/* Также можно делать прямую и uniform (C++11 и выше) инициализацию */
int *ptr1 = new int (7); // используем прямую инициализацию
int *ptr2 = new int { 8 }; // используем uniform инициализацию (в C++11 и выше)
```
Динамическое выделение памяти не обладает свойствами автоматического, такими как автоматическое очищение и удаление переменных после выхода из блока. Надо самостоятельно *удалить* (т.е. вернуть выделенную память назад ОС) и *очистить указатель* (т.к. даже после возвращения выделенной памяти, указатель продолжить указывать на ее адрес. Может получиться, что ОС уже выделила эту память другому процессу, а указать все еще указывает - это **висячий указатель**). 
```cpp
delete ptr; // возвращаем память обратно в операционную систему. ptr теперь висячий указатель
ptr = 0; // (или ptr = nullptr;) ptr теперь уже nullptr (не сможет указать на этот участок память)
```
Этого можно не делать, если сразу после инструкции `delete ptr;` блок заканчиватся, тогда `prt` будет удален автоматически. 

### исключение *bad_alloc*
Может получится так, что у ОС не будет памяти для выделения, и тогда оператор `new` вместо адреса вызовет исключение `bad alloc`, и все покрашится. С этой целью есть специальная константа: `(std::nothrow)` - если ее указать между `new` и типом данных, то в случаи `bad alloc` оператор `new` вернет `nullptr`. Однако даже так, если программа пойдет дальше использовать этот указатель, то все может покрашится. Чтобы этого избежать, надо делать проверку того, что память выделилась:
```cpp
int *value = new (std::nothrow) int; /* запрос на выделение динамической памяти для целочисленного значения
вернет nullptr, если не сможет выделить память */
if (!value) // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
{
    	// Обработка этого случая
	std::cout << "Could not allocate memory";
}
else
{
	// do your beautiful code
}
```
### Утечка памяти (memory leak)
Динамически выделенная память не имеет области видимости, т.е. она остаётся выделенной до тех пор, пока не будет явно освобождена или пока ваша программа не завершит своё выполнение (и операционная система очистит все буфера памяти самостоятельно). Однако указатели, используемые для хранения динамически выделенных адресов памяти, следуют правилам области видимости обычных переменных. Когда ваша программа теряет адрес (т.е. "теряет" указатель) некоторой динамически выделенной части памяти (например, переменной или массива), прежде чем вернуть её обратно в операционную систему - это **утечка памяти (memory leak)**. Подобное может произойти например в следующих случаях:
```cpp
// указатель использовали для другого случая, напр., переменной */
int value = 7;
int *ptr = new int; // выделяем память
ptr = &value; // старый адрес утерян - произойдёт утечка памяти
// дважды выделили память, но использовали только один указатель
int value = 7;
int *ptr = new int; // выделяем память
ptr = &value; // старый адрес утерян - произойдёт утечка памяти
```

---

# Chapter 5 Data types

## Basic data types   
1 byte = 8 bit = 2^8 = 256. So 1 byte is range of 0 to 255 (если без знака).  Размер определённых типов данных зависит от компилятора и/или архитектуры компьютера! C++ гарантирует только их минимальный размер (см. таблицу). 
Каждый байт имеет свой адрес. Т.е. если переменная весит 4 байта, то в памяти она "заняла" 4 адреса.
### Встроенные типы   
|Type|Size|range|
|:---|----:|:----|
|char| 1byte|-127 to 127 or 0 to 255|
|unsigned char*|	1byte|	0 to 255|
|signed char|	1byte	|-127 to 127
|int|	4bytes	|-2147483648 to 2147483647
|unsigned int*|	4bytes|	0 to 4294967295
|signed int	|4bytes	|-2147483648 to 2147483647
|short int|	2bytes	|-32768 to 32767
|unsigned short int*| -	|0 to 65,535
|signed short int|	-|	-32768 to 32767
|long int	|4bytes|	-2,147,483,648 to 2,147,483,647
|signed long int|	4bytes|	same as long int
|unsigned long int*|	4bytes|	0 to 4,294,967,295
|float|	4bytes|	+/- 3.4e +/- 38 (~7 digits)
|double|	8bytes|	+/- 1.7e +/- 308 (~15 digits)
|long double|	8bytes|	+/- 1.7e +/- 308 (~15 digits)|  

*Использование `unsigned` нежелательно.

**Other**
- `bool` - logic (1 byte) - 1 байт т.к. нужен адрес, а минимальный размер с адресом - 1 байт.
- `void` - empty data type (исп. в 1) ф-циях: `void function(){}` - ничего не возвращает, 2) в указателях)  

#### Prefixes 
1. `long ..` int (or double) - 4 bytes ($\pm 2*10^6$) (or 8 bytes) 
2. `sort ..` int - 2 bytes 
3. `unsigned ..` - only *positive*
4. `signed ..` - both *postive* and *negative*
5. `float` vs `double` (точность выше, чем у float) - 4 vs 8 bytes 
Объявлять можно просто префиксом: `short x = 10`, `long long y = 100` (int подразумевается, но явно не указывается).

### char
Целочисленный тип данных, т.е. хранит в себе int (-127 до 127). Это число конвертируется в ASCII (от англ. «American standard code for information interchange»). От 97 до 122 англ буквы. При этом не важно как ее инциализировать символом (`'a'`) или числом ASCII:
```cpp
char ch1(97); // инициализация переменной типа char целым числом 97
char ch2('a'); // инициализация переменной типа char символом 'a' (97)
```
Вывод будет по стандарту - символ. Чтобы вывести число, нужно конвертирова char -> int: 1й способ сохранить char в новую переменную типа int (не желательно), 2й способ использовать `static_cast<int>(ch)` (желательно).

**char16_t и char32_t**   
Нужны для использования других (не ASCII) символьных кодировок (напр., Unicode, который имеет в запасе более 110 000 целых чисел для представления символов из разных языков). Так, есть UTF-32 (требует 32 бита для представления символа, `char32_t`) и UTF-16 (требует 16 бит для представления символа, `char16_t`).

### Фиксированный размер int
Требуется подключить библеотеку `#include <cstdint>` стандартной библиотеки (не забудь namespace std/std::). 
1 байт(8 бит): `int8_t` (signed), `uint8_t` (unsigned).  
2 байта: `int16_t` (signed), `uint16_t`(unsigned).  
4 байта: `int32_t` (signed), `uint32_t` (unsigned).   
8 байт: `int64_t` (signed), `uint64_t` (unsigned).   
- Многие компиляторы автоматически переводят `std::int8_t` и `std::uint8_t` в `char`, будь аккуратен.  

### float/double: ошибки округления
Возьмем дробь 1/10. В десятичной системе счисления эту дробь можно представить как 0.1, в двоичной системе счисления эта дробь представлена в виде *бесконечной* последовательности: 0.00011001100110011… Именно из-за подобных разногласий в представлении чисел в разных системах счисления — у нас могут возникать проблемы с точностью. Например:
```cpp
#include <iostream>
#include <iomanip> // для std::setprecision()
 
int main()
{
    std::cout << std::setprecision(17);
 
    double d1(1.0);
    std::cout << d1 << std::endl;					  // выйдет 1
	
    double d2(0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1); // должно выйти 1.0
    std::cout << d2 << std::endl;					  // но выйдет 0.99999999999999989
}
```
Из за этого же есть проблемы со сравнением двух float чисел т.к. в примере выше 1.0 != 0.99999999999999989. Для этого можно использовать `epsilon ф-циию сравнения`:
```cpp
// Возвращаем true, если разница между a и b меньше absEpsilon или в пределах relEpsilon 
bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)
{
    // Проверяем числа на их близость - это нужно в случаях, когда сравниваемые числа являются нулевыми или около нуля
    double diff = fabs(a - b);
    if (diff <= absEpsilon)
        return true;
 
    // В противном случае, возвращаемся к алгоритму Кнута («Искусство программирования, том 2: Получисленные алгоритмы» (1968))
    return diff <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * relEpsilon);
}
```

### nan и inf
Особые типы:   
`inf` (или «бесконечность», от англ «infinity»): может быть положительной и отрицательной.
`nan` (или ещё «не число», от англ «not a number»). 
```cpp
double zero = 0.0;
double posinf = 5.0 / zero; // положительная бесконечность 
std::cout << posinf << "\n";
 
double neginf = -5.0 / zero; // отрицательная бесконечность 
std::cout << neginf << "\n";
 
double nan = zero / zero; // не число (математически некорректно)
std::cout << nan << "\n";
```
### constants
Константы должны быть сразу объявлены (т.е. со значением). Нельзя сначала инициализировать, а потом присвоить значение.  
```cpp
const double gravity { 9.8 };   // предпочтительнее использовать const перед типом данных
int const sidesInSquare { 4 };  // ок, но вариант выше - лучше

g =  9.8 		        // можно инициализоровать переменной
const double gravity {g};
```
- Можно явно указать, что константа является константой времени компиляции: `constexpr int  = 1`. Это особо не нужно т.к. компилятор сам умеет определять тип константы. 

### auto
Ключевое слово auto использовалось для явного указания, что переменная должна иметь автоматическую продолжительность. Однако, поскольку все переменные в новых версиях C++ по умолчанию имеют автоматическую продолжительность, и, если явно не указывать другой тип продолжительности, то ключевое слово auto стало лишним и, следовательно, устаревшим. Начиная с C++11, ключевое слово auto при инициализации переменной может использоваться вместо типа переменной, чтобы сообщить компилятору, что он должен присвоить тип переменной исходя из инициализируемого значения. Можно использовать для:

1. Инициализации переменных: `auto num = 12;`. Т.к. компилятор определяет тип по присваиваему значние, то просто объявить с auto нельзя. 
2. Автоматическое определение типа возвращаемого значения функции (С++ 14 и выше):
	```cpp
	// это считаетяс плохой практикой
	auto subtract(int a, int b)
	{
	    return a - b;
	}
	```
3. В loop, где надо выводить содержание итерируемых контейнеров
	```cpp
	vector<int> nums= {1,2,3};
	for (auto c: nums){cout << c << ",";}
	```
4. Cинтаксис trailing
	```cpp
	auto subtract(int a, int b) -> int;
	auto divide(double a, double b) -> double;
	auto printThis() -> void;
	```	

## Преобразование типов 
Есть два типа преобразования типов данных в C++: неявное и явное.   
1. **Неявное преобразование данных** -компилятор автоматически преобразовывает данные, чтобы корректо с ними работать. Есть несколько уровней неявных (автоматических) преобразований:
- **Числовое расширение** - это когда значение из одного типа данных конвертируется в другой тип данных побольше (по размеру и по диапазону значений). Так типы меньше, чем `int` (`bool`, `char`, `short int` (или просто `short`), включая их unsigned и signed версии) расширяется в `int`. Также `float` конвертируется в `double`. Например, 
	```cpp
	long l(65); // расширяем значение типа int (65) в тип long
	double d(0.11f); // расширяем значение типа float (0.11) в тип double
	```
При числовом расширении данные не теряются из-за переполнения.
- **Числовые конверсии** -  когда конвертируем значение из более крупного типа данных в аналогичный, но более мелкий тип данных (напр., `int` в `short`, `float` в `double`), или конвертация происходит между разными типами данных (напр., `int` в `char`). Например,
	```cpp
	// без переполнения и потери данных
	double d = 4; // конвертируем 4 (тип int) в double
	short s = 3;  // конвертируем 3 (тип int) в short
	// произойлет переполнение
	int i = 30000;
	char c = i;   // т.к. char (-127, 127), то произойдет переполнение. Результат будет 48 
	// еще переполнение 
	float f = 0.123456789; // значение типа double - 0.123456789 имеет 9 значащих цифр, но float может хранить только 7
	```
- **Обработка арифметических выражений** Арифметические операторы требуют, чтобы их операнды были одного типа данных. Для этого преобразует один или оба операнда по правилам: 1) Если операндом является целое число меньше (по размеру/диапазону) типа int, то оно подвергается интегральному расширению в int или в unsigned int. 2)Если операнды разных типов данных, то компилятор вычисляет операнд с наивысшим приоритетом и неявно конвертирует тип другого операнда в соответствие к типу первого.
	```cpp
	double a(3.0);
	short b(2);
	std::cout << a + b << std::endl; // тип данных в выражения (a + b) - double, при этом b будет конвертирован short -> double
	```	
2. **Явные преобразования**   
**C-style cast** 
```cpp
int i1 = 11;
int i2 = 3;
float x = (float)i1 / i2;
// или то же свмое
float x = float(i1) / i2;
```
Не рекомендуется использовать C-style т.к. он может помянть тип `const` переменных и все поломать.
**static_cast**
```cpp
char c = 97;
std::cout << static_cast<int>(c) << std::endl; // в результате выведется 97, а не 'a'
```

## typedef (alias)
`typedef double time_t;` - стейтмет позволяющтий использовать псевдоним (alias) для типа данных. Тип данных при этом остается тем же (в прим., `double`), но для удобства чтения/написания кода будет использлваться новое имя будто это новый тип (в прим.,`time_t`). Например,
```cpp
/* тип данных  std::vector<std::pair<std::string, int> >   заменен на имя по-проще */ 
typedef std::vector<std::pair<std::string, int> > pairlist_t; // используем pairlist_t в качестве псевдонима 

pairlist_t pairlist; // объявляем pairlist_t
 
boolean hasAttribute(pairlist_t pairlist) // используем pairlist_t в качестве параметра функции
{
    // Что-то делаем
}

```
Два эквивалентных способа переименования:
```cpp
typedef double time_t; // используем time_t в качестве псевдонима для типа double
using time_t = double; // используем time_t в качестве псевдонима для типа double
```

## std:: типы данных
### Строка
```cpp
#include <string>
string nm = "Hello, world!";
```
#### Методы
- `my_str.length()` - возвращает длинну строки
- `std::getline(std::cin, my_str)` - cin принимает строку целиком не прирываясь на пробелах (если без getline(), то cin принимает строку до пробела). Параметры: (std::cin, строка)
- `std::cin.ignore(32767, '\n')` -  игнорирует до 32767 символов до тех пор, пока \n не будет удалён из потока. Это нужно когда за cout идет getline():
```cpp
std::cout << "Pick 1 or 2: ";
int choice;
std::cin >> choice; 		/* (пусть мы выбрали 2) когда мы ввели 2, cin фактически получил '2\n', 
тогда поэтому следующий стейтмент std::getline(std::cin, myName) получит '\n' 
std::cin.ignore(32767, '\n');  - этот стейтмент все исправит */
std::cout << "Now enter your name: ";
std::string myName;
std::getline(std::cin, myName);
```

### Array
```cpp
#include <array>
// при объявлении или инициализации
std::array<int, 4> myarray0;
std::array<int, 4> myarray1 = { 8, 6, 4, 1 }; // список инициализаторов
std::array<int, 4> myarray2 { 8, 6, 4, 1 }; // uniform инициализация

// Доступ к значениям массива через оператор индекса осуществляется как обычно
myarray[2] = 7;
```
В отличии от обычных массивов, `std::array` передаются в ф-ции не распадаясь в указатель, поэтому с ними удобно работать в ф-циях.
```cpp
void printLength(const std::array<double, 4> myarray)
{
	for (auto a: myarray)		// будет работать! В отлиции от обычных массивов
		std::cout << "length: " << a;
}

int main()
{
	std::array<double, 4> myarray{ 8.0, 6.4, 4.3, 1.9 };
	printLength(myarray);
}
```

#### Методы
- `myarray.at(8) = 7;` - проверяет, существует ли элемент 8 (достаточно ли велик массив), если да, то возвращает ссылку на этот элемент, которой может быть присвоено значение. Если нет, то вернет исключение `std::out_of_range`. Все аналогичего `myarray[8] = 7`, только тут проверяются границы массива. 
- `myarray.size()` - возвращает длинну массива.


### Vector (одномерный массив любого типа)
Это тот же динамический массив, но который может сам управлять выделенной себе памятью. Это означает, что вы можете создавать массивы, длина которых задаётся во время выполнения, без использования операторов new и delete (явного указания выделения и освобождения памяти). Когда переменная-вектор выходит из области видимости, то она *автоматически освобождает память*, которую контролировала (занимала). Это не только удобно (так как вам не нужно это делать вручную), но также помогает предотвратить утечки памяти.
```cpp
#include <vector>
 // Нет необходимости указывать длину при инициализации
std::vector<int> array0; // векстор рамера 0
std::vector<int> array1(n); // векстор рамера n, где n-comlile-time constant
std::vector<int> array2 = { 10, 8, 6, 4, 2, 1 }; // используется список инициализаторов для инициализации массива
std::vector<int> array3 { 10, 8, 6, 4, 2, 1 }; // используется uniform инициализация для инициализации массива (начиная с C++11)

std::vector<bool> array4(28, false); // создает вектор из 28 элементов и инициализирует все его элементы false
 ```
Подобно std::array, доступ к элементам массива может выполняться как через оператор [] (который не выполняет проверку диапазона), так и через функцию at() (которая выполняет проверку диапазона):
```cpp
array[7] = 3; // без проверки диапазона 
array.at(8) = 4; // с проверкой диапазона
```
Вектор будет самостоятельно изменять свою длину, чтобы соответствовать количеству предоставленных элементов:
```cpp
array = { 0, 2, 4, 5, 7 }; // хорошо, длина array теперь 5
array = { 11, 9, 5 }; // хорошо, длина array теперь 3
```
#### Методы
- `array.at(8) = 4;`  - налогично вызову для `std::array`. Это присвоение с проверкой диапозона.
- `array.size()` - возвращает длинну вектора.
- `array.resize()` - изменяет длинну вектора. Например 
	```cpp
	std::vector<int> array { 0, 1, 2 };
   	array.resize(7); /* изменяем длину array на 7. Теперь это {0 1 2 0 0 0 0} - автоматически дополнилось нулями */
	
	 std::vector<int> array { 0, 1, 4, 7, 9, 11 };
    	array.resize(4); /* изменяем длину array на 4. Теперь это {0 1 4 7} */
	```
- `array.back()` - возвращает последний элемент вектора
- `array.push_back(n)` - присоединит n в конец вектора (append)
- `array.pop_back(n)` - удаляет последний элемент вектора
- `array.empty()` - проверяет не пуст ли вектор (bool)
- `array.clear()` - очистить вектор
- `vector.assign(n, val)` - assigns new contents to the vector, replacing its current contents (*val*), and modifying its size (*n*) accordingly
- `vector.resize(n) /*or*/ vector.resize(n, val)` - Resizes the container so that it contains *n* elements. If *n* is smaller than the current container size, the content is reduced to its first *n* elements, removing those beyond (and destroying them). If *n* is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n (if *val* is specified, the new elements are initialized as copies of *val*, otherwise, they are value-initialized). If *n* is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place.

	
 ### Словарь
 ```cpp
 #include <map>
 map<string, int> name_to_value; //<key_type: value_type>
 name_to_value["one"] = 1;
 name_to_value["two"] = 2;   
 cout << "two is " << name_to_value["two"];
 
 // используется список инициализаторов для инициализации массива
 map<string, int> name_to_value2 = {{"one",1}, {"two",2}, {"Three",3}};
```
Вызвов ключей(`.first`) и значений(`.second`):
```cpp
map<string, int> abc = {{'a':1}, {'b':2}, {'c':3}}
for (auto i: abc) {                         // тут i - это пара key: values
    cout << i.first;                        // вывод key (т.е. 'a')
    cout << i.second;}                      // вывов values (т.е. 1)
```
Если вызвать словарь с несуществующим ключом, то автоматически будет создана пара {key:default_value} (напр, для int default_value = 0):
```cpp
map<char, int> dict;	// пустой словать 
dict['p'];		// ключа 'p'нет, поэтому словать создаст пару {'p':0} (т.к. по дефолту int это 0)
			// теперь словать имеет длинну 1 (одну пару)
```

#### Методы
- `map.size()` - размер словаря (те кло-во пар ключ:значение)
- `map.erase(key)` - удалит пару, соотвутсвующую key
- `map.count(key)` - возвращает сколько раз key встречается в словаре. Тк все key в нем уникальны, то возвращет 1 (если есть) и 0 (если нет)
    
#### В С++ 17 
Появилась возможность удобнее итерировать по словарю использую нотацию `[key, value]`:
```cpp
 map<string, int> name_to_value = {{"one",1}, {"two",2}, {"Three",3}};
 for (const auto& [key, value] : name_to_value)
 {/* прямо использовать key и value (вместо name_to_value.first, name_to_value.second) */ }
```

#### Снипет для подсчета повторений
Тк какждый вызов вида `map[key]` возвращает `value` (если такой ключ есть) или создает и возращает 0 (если такого ключа нет), то можно создать кэш на этой основе. 
```cpp
std::map<char, int> letter_count;
for (auto& letter : str)
{
	++letter_count[letter]; /* если букву встретили 1й раз, то создается пара key:value (автоматически value = 0).
	Если буква уже была, то делаем letter_count[letter] = letter_count[letter] + 1. Таким образом получим словать,
	где key - уникальные быквы в слове (string), а value - кол-во совпадений (отсчет идет от 0, те value =0 -> одно
	совпадение, value = 2 -> 3 совпадения и тд. */
}
return letter_count;
```
    
## Arrays (массивы)
### Regular and N-dimetional arrays
#### Объявление и заполнение 
```cpp
int array[5] = { 0, 1, 2, 3, 4 }; // явно указываем длину массива через список инициализаторов 
int array[] = { 0, 1, 2, 3, 4 }; // список инициализаторов автоматически определит длину массива
```
Автоматическое заполнение массива нулями: если при инициализации задан размера массива, список инициализаторов не полный, то компилятор автоматически заполнит остаток нулями:
```cpp
int ones_array[5] = { 5, 7, 9 }; 	// Инициализируем только первых 3 элемента, остальное нули
int second_array[5] = { }; 		// Инициализируем все элементы массива значением 0

int third_array[5] { 4, 5, 8, 9, 12 };	// используем uniform-инициализацию для инициализации фиксированного массива
```
Массивы может состоять из элементов любого типа (как стандартных, так и пользовательских). Например, массив из `struct`:
```cpp
struct Rectangle
{
    int length;
    int width;
};
Rectangle rects[4]; // объявляем массив с 4-ма прямоугольниками
```

**Объявление с помощью перечислений (enum)**    
Т.к. индексы массива - это только int числа, то можно сделать связку array + enum для того, чтобы иметь именные индексы:
```cpp
enum StudentNames
{
    SMITH, // 0
    ANDREW, // 1
    IVAN, // 2
    JOHN, // 3
    ANTON, // 4
    MAX_STUDENTS // 5 		// Вводится, чтобы удобно было создавать массив (т.к. нумерация с 0)
};
 
int main()
{
    int testScores[MAX_STUDENTS]; // всего 5 студентов
    testScores[JOHN] = 65;
}
```
Если использовать `enum class` (чтобы иметь область виденья внутри enum), то индексы надо будет вручную кокнвертировать из `int testScores[StudentNames::JOHN] = 65;` в `testScores[static_cast<int>(StudentNames::JOHN)] = 65;`. Проще избегать класса enum, и просто вставить его в свой собственный namespace:
```cpp
namespace StudentNames
{
    enum StudentNames
    {
        SMITH, // 0
        ANDREW, // 1
        IVAN, // 2
        JOHN, // 3
        ANTON, // 4
        MISHA, // 5
        MAX_STUDENTS // 6
    };
}
 
int main()
{
    int testScores[StudentNames::MAX_STUDENTS]; // всего 6 студентов
    testScores[StudentNames::JOHN] = 65;
}
```

**Дополнительно**   
1. *(Внимание!)* В С++ нет проверки на диапозон индексирования, поэтому компилятор не заметит, если выйти за размеры массива. В этом случаи он начнет переписывать учстки памяти занятые другими переменными и все станет оч плохо:
	```cpp
	// компилятор не заметит этого, и ошибки не будет! 
	int array[5]; // массив содержит 5 простых чисел
	array[5] = 14;
	```
2. *(Можно не париться)* При объявлении массива фиксированного размера, его длина (между квадратными скобками) должна быть константой типа **compile-time** (которая определяется во время компиляции). **Хотя, большинство компиляторов ругаться не будут**. Например,
	```cpp
	const int length = 4;
	int array[length]; 	// хорошо length - compile time

	/* На самом деле можно не заморачиваться, т.к. большинство компиляторов ругаться не будут
	и все будет работать корректно */
	int length = 4;
	int array[length]; 	// плохо length не compile time

	int width;
	std::cin >> width;
	int array[width]; 	// плохо: width должна быть константой типа compile-time!

	// Используем константную переменную типа runtime
	int temp = 8;
	const int width = temp;
	int array[width];	// плохо: здесь width является константой типа runtime, но должна быть константой типа compile-time!
	```
#### Указатели и массивы
При объявлении массива (напр., `int my_array[4] = { 5, 8, 6, 4 };`) в переменную my_array сохраняется адрес первого элемента массива. Сама переменная имеет тип `int[4]`. Это создает принципиальное отличиие переменной массива от простого указателя на первый элемент (тип которого будет `int *`). Тип `int[4]` - несет в себе адрес 1го элемента и длинну массива, а также она знает, что это массивю. Тип`int *` - это просто указатель на первый int из массива (он не знает ни длинну, ни факт, что это массив). При некоторых действиях (напр., передача в ф-ции) массива **распадается (decay)** (т.е. неявно преобразовывается компилятором) из `int[4]` в указатель на первый элемент `int *`.
```cpp
int my_array[4] = { 5, 8, 6, 4 };
// Выводим значение массива (переменной array)
std::cout << "The my_array has address: " << my_array << '\n';	// The array has address: 004BF968
// Выводим адрес элемента массива
std::cout << "Element 0 has address: " << &my_array[0] << '\n';	// Element 0 has address: 004BF968
// my_array распадается в указатель на превый элемент
int *ptr = my_array;
std::cout << "Element 0 has address: " << prt;			// Element 0 has address: 004BF968

std::cout << *my_array; 	// выведется 5
std::cout << *ptr; 		// выведется  5
/* Адрес будет совпадать, однако компилятор будет рассматривать их по разному: см. ниже */
```
Принципиальное отличие между указателем на первый элемент (`&array` и `ptr`) и самой переменной `my_array` то, что компилятор рассматривает их как разные типы данных. Например, 
```cpp
int array[4] = { 5, 8, 6, 4 };
std::cout << sizeof(array) << '\n'; 	// выведется sizeof(int) * длина array (выведет: 16)
 
int *ptr = array;
std::cout << sizeof(ptr) << '\n'; 	// выведется размер указателя, т.е. адреса памяти в байтах (выведет: 4)
```
#### Память и индексация (array[i]) 
На самом деле, элементы массива имеют последовательные адреса памяти. Т.е.: 
```cpp
int array[] = { 7, 8, 2, 4, 5 };
 
std::cout << "Element 0 is at address: " << &array[0] << '\n';	// Element 0 is at address: 002CF6F4
std::cout << "Element 1 is at address: " << &array[1] << '\n';	// Element 1 is at address: 002CF6F8
std::cout << "Element 2 is at address: " << &array[2] << '\n';	// Element 2 is at address: 002CF6FC
std::cout << "Element 3 is at address: " << &array[3] << '\n';	// Element 3 is at address: 002CF700
// т.е. различаются все на 4 байта (рамер int)
```
Так как оперция `ptr + 1` выдает адрес следующего элемента того же типа, что и указатель `ptr` (см. **арифметика указателей**), то индексация массива (`array[i]`) - это просто псевдоним для арифметики над первым элементом массива т.е.: `array[i]` — это то же самое, что и `*(array + i)` (где i - индекс массива, `*()`- разименование элемента памяти с адресом `array + i` (т.е. первый элемент + i).
```cpp
 std::cout << &array[1] << '\n'; 	// выведется: 001AFE74 (адрес памяти элемента под номером 1)
 std::cout << array+1 << '\n'; 		// выведется: 001AFE74 (адрес памяти указателя на массив + 1) 
 
 std::cout << array[1] << '\n'; 	// выведется: 8
 std::cout << *(array+1) << '\n'; 	// выведется: 8 (обратите внимание на скобки, они здесь обязательны)
```

#### Передача массива в функции
(см. главу про функции, раздел аргументы)

#### Sizeof of array
Общий размер массива - это длина массива умножена на размер одного элемента (в байтах). Надо быть аккуратным при использовании оператора `sizeof`:
```cpp
void printSize(int array[])
{
    std::cout << sizeof(array) << '\n'; 	/* выводится размер указателя, а не массива
    т.к. в ф-цию передается указатель на массива, а не сам массив */
}
 
int main()
{
    int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
    std::cout << sizeof(array) << '\n'; 	// выводится размер массива
    printSize(array);				// в ф-цию передается указатель на массив	
}
```
Как найти размер массива, длина которого не была явно указана? Так:
```cpp
int array[] = { 1, 3, 3, 4, 5, 9, 14, 17 };
std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
```
#### n-dimensional array
**Объявление и присвоение**
В двумерном массиве первый (левый) индекс принято читать как количество строк, а второй (правый) как количество столбцов:
```cpp
int array[2][4];   // 2-элементный массив из 4-элементных массивов
array[1][3] = 7;   // без приставки int (типа данных)
```
**Инициализация** 
```cpp
int array[3][5] =
{			// обрати внимание на внешние {}
{ 1, 2, 3, 4, 5 },	// строка №0
{ 6, 7, 8, 9, 10 },	// строка №1
{ 8, 9, 11}		/* строка №2 = 8, 9, 11, 0, 0 - тут
			так же работает автозаполнение нулями */
};

// Заполнение нулями
int array[3][5] = {};
```
В двумерном массиве со списком инициализаторов можно не указывать только левый индекс (авто определение длинны):
```cpp
// тут все ОК
int array[][5] =
{			
{ 1, 2, 3, 4, 5 },
{ 6, 7, 8, 9, 10 },
{ 11, 12, 13, 14, 15 }
};

// тут будет ошибка
int array[][] = 
{
{ 3, 4, 7, 8 },
{ 1, 2, 6, 9 }
};
```

### Dynamic arrays
Для выделения динамического массива используется отдельная форма операторов `new` и `delete` для работы с массивами: `new[]` и `delete[]`. Можно вместо `new[]` использовать просто `new` (для `delete[]` нельзя), т.к. компилятор сам применит нужный оператор из контекста.
```cpp
std::cout << "Enter a positive integer: ";
int length;
std::cin >> length;
 
int *array = new int[length]; /* используем оператор new[] для выделения массива. Обратите внимание,
переменная length не обязательно должна быть константой! */
 
std::cout << "I just allocated an array of integers of length " << length << '\n';
array[0] = 7; // присваиваем элементу под номером 0 значение 7
 
delete[] array; // используем оператор delete[] для освобождения выделенной для массива памяти
array = 0; // используйте nullptr вместо 0 в C++11
```
**Иницаплизация динамического массива**:
```cpp
int *array = new int[5] { 9, 7, 5, 3, 1 }; // инициализируем через список инициализаторов
```
Важно отметить, что массива может быть инициализирован только один раз и с явным указанием размера (напр., `
int *dynamicArray1 = new int[] {1, 2, 3};` - нельзя). Чтобы изменить динамический массив надо создать новый и скопировать содержимое в него. В этому случаии лучше использовать `std::vector` (он изменяется).  Также, динамически нельзя выделить память для C-style строки. Однако, можно это сделать для `std::string`.

#### 2-dimensional dynamic arrays
Они создаются на основе массива указателей. Если следующие способы их создания:
1. Если кол-во строк (rows) известно т.е. это compile-time constant, то динамически создается массив, который запоняется указателями на массивы рамера row. 
```cpp
int (*array)[7] = new int[15][7];	// 7 - num of rows (compile-time const), 15 - num of columns (run-time const)
/* начиная с С++11 можно использовать auto. В этом случаи оно само укажет, что это динамический массива, состоящий из
массивов рамера [7].
auto array = new int[15][7]; 		// То же самое, но намного проще!
```
2. Если обе рамерности 2-мерного массива - это константы типа run-time, то синтаксического сахара для них нет. Надо выделить массив (указателей на указатели) рамера num_of_columns и в цикле заполнить его выделенными массивами (вложенных указателей) размера num_of_rows:
```cpp
int **array = new int*[15]; // выделяем массив из 15 указателей типа int — это наши строки
for (int count = 0; count < 15; ++count)
    array[count] = new int[7]; // а это наши столбцы
    
/* Доступ к элементам массива выполняется как обычно */
array[8][3] = 4; // это то же самое, что и (array[8])[3] = 4;
```
Если надо, можно создать и не прямоугольные массив (например треугольный):
```cpp
int **array = new int*[15]; // выделяем массив из 15 указателей типа int — это наши строки
for (int count = 0; count < 15; ++count)
    array[count] = new int[count+1]; // а это наши столбцы
```

**Удаление массива**    
Надо опять же циклом освободить память от каждого из вложенных массивов, а потом от основного:
```cpp
for (int count = 0; count < 15; ++count)
    delete[] array[count];	// удалили вложенный массив
delete[] array; 		// удалили основной массив
```

**Проще "сгладить" массива, чем выделять 2D динамически**    
Часто, просще сделать 1D массива вместо 2D, где столбцы записаны один за другим ("сглажены"). Тогда для извлечения по индексам имеет смысл создать ф-цию, которая сам их обработает:
```cpp
// Вместо следующего:
int **array = new int*[15]; // выделяем массив из 15 указателей типа int — это наши строки
for (int count = 0; count < 15; ++count)
    array[count] = new int[7]; // а это наши столбцы 
 
// Делаем следующее: 
int *array = new int[105]; // двумерный массив 15x7 "сплющенный" в одномерный массив

// Ф-ция обработки индексов
int getSingleIndex(int row, int col, int numberOfColumnsInArray)
{
     return (row * numberOfColumnsInArray) + col;
}
 
// Присваиваем array[9,4] значение 3, используя наш "сплющенный" массив
array[getSingleIndex(9, 4, 5)] = 3;
```

## C-style strings
- Не рекомендуются к использованию из за опасности переполнения. Лучше использовать `std::string`.     
Это char массив. В конце строки компилятор сам добавит int 0. По нему он будет определять конец строки (напр., std::cout закончит вывод на int 0). В итоге, длинна массива будет на +1 больше. 
```cpp
char mystring[] = "string";		// лучше, чтобы компилятор сам определял длинну массива
mystring[1] = 'p';			// выведет 'spring'
```
Т.к. это по сути статический массив, то перед использованием его длинна должна быть определена. Это затрудняет использование С-style строк с оператором std::cin. В этом случаи можно объявить большой массива (напр., 255 символов) и принимать значения с помощью ф-ции `getline(str, num)`, она принимает только указанное число символов (это исключит переполнение): 
```cpp
char name[255]; 			// объявляем достаточно большой массив (для хранения 255 символов)
std::cout << "Enter your name: ";	// cin.getline() будет принимать до 254 символов в массив name 
std::cin.getline(name, 255);
std::cout << "You entered: " << name << '\n';
```
### <csting>
Библиотека полезных ф-ций для C-style sting.   
- `strcpy_s(new_str, old_str)` - копирует содержимое одной строки (old_str) в другую(new_str).
- ` strlen(my_str)` - возвращает длину строки C-style (без учёта нуль-терминатора). Причем,
	```cpp
	char name[15] = "Max"; 	// используется только 4 символа (3 буквы + нуль-терминатор)
    	std::cout << name << " has " << strlen(name) << " letters.\n";			// проверяет кол-во символов
    	std::cout << name << " has " << sizeof(name) << " characters in the array.\n" 	// проверяет размер массива
	/* выведет: Max has 3 letters. Max has 15 characters in the array. */
	```
- `strcat()` — добавляет одну строку к другой (опасно из за возможности переполнения);
- `strncat()` — добавляет одну строку к другой (с проверкой размера места назначения);
- `strcmp()` — сравнивает две строки (возвращает 0, если они равны);
- `strncmp()` — сравнивает две строки до определённого количества символов (возвращает 0, если они равны).
	
### C-style string symbolic constants
```cpp
char myName[] = "John";
const char *myName = "John";
```
Эти два объявления создают одинаковую C-style строку, но их организация разная. В 1ом случаи компилятор созадет `char array[5]` с содержимым `John\0`. Во 2ом случаи, компилятор создает строковый литерал `John\0` и записывает ее в read-only память. Несколько строковых литералов с одним и тем же содержимым могут указывать на один и тот же адрес (это значит, что если где-то в программе создается еще один строковый литерал `John\0`, то он поделит адрес с этой строкой).


## User-defined data types
**Пара общих фич**   
1. Объявление enum, struct ... не требует выделения памяти, то для них нельзя сделать предварительное объявление (прототип) при использовании из другого файла. Но есть обходной путь: чтобы использовать объявление структуры в нескольких файлах (чтобы иметь возможность создавать переменные этой структуры в нескольких файлах), надо поместить объявление структуры в заголовочный файл и #include этот файл везде, где необходимо использовать структуру. Тогда при #include объявление структуры будет просто добавлено в файл. 

### Enumeration (enum) type
#### Обычный перечислитель   
Это контейнер, который хранит в себе пары {name:int}. При этом, номера (int) идут последовательно, если число явно неуказано. Так, если первый элемен не указан явно, то ему приписывается 0. Второму элементу 1 и т.д. Каждый следующий элемент по дефолту +1 от предыдущего. . По сути, в enum хранятся переменные и соответствующие им int. **enumeration (enum)** - это контейнер, **enumerator** - это элемент контейнера.
```cpp
// define a new enum named Animal
enum Animal
{
    ANIMAL_CAT = -3,	// если бы не было указано явно, то было бы 0
    ANIMAL_DOG, 	// assigned -2 (т.к. предыдущий -3)
    ANIMAL_PIG, 	// assigned -1
    ANIMAL_HORSE = 5,
    ANIMAL_GIRAFFE = 5, // shares same value as ANIMAL_HORSE
    ANIMAL_CHICKEN 	// assigned 6 (т.к. предыдущий 5)
};
```
Компилятор автоматически не конвертирует int -> enymerator. А наоборот (enymerator -> int) все ОК:
```cpp
Animal my_animal = 6; 	// will cause compiler error 
Animal my_animal = static_cast<Animal>(6); // OK. Создаст enumerator my_animal = Chicken = 6

int mypet = ANIMAL_PIG;  // OK. mypet = -1 (это будет обычный int)
```
**Input/output** - воодится и выводится соответсвующий int: 
```cpp
//evaluates to integer before being passed to std::cout
std::cout << ANIMAL_HORSE; 	// вернет 5
```
Компилятор автоматически не конвертирует int -> enymerator. Т.е.:
```cpp
Animal my_animal = 6; // will cause compiler error 
Animal my_animal = static_cast<Animal>(6); // OK. Создаст enumerator my_animal = 6 (т.е. ANIMAL_CHICKEN)
```
Вывод имя перечислителя (напр., ANIMAL_CHICKEN) нельзя. Выкрутиться можно через if-else:
```cpp
void printAnimal(Animal my_animal)
{
    if (my_animal == ANIMAL_CAT)
        std::cout << "Cat";
    else if (my_animal == ANIMAL_DOG)
        std::cout << "DOG";
```
Это все из за того, что перечеслитель - это просто название переменной.

**Scope**     
Обычные пречислители в глобальной области видимости. Отсюда могут идти ошибки т.к. мы можем сравить например ANIMAL_CHICKEN (= 6) и COLOR_PINK (=6) из разных enum, и получить True (а хорошо бы, чтобы они не сравнивались и вообще не видели друг друга).

**Память**    
В среднем enumerator весит как обычный int, но это может зависеть от компилятора.

#### Enum classes
Для того, чтобы enum имели локальную видимость и не были в глобальном namespace, (в С++ 11) ввели `enum class` (also called a scoped enumeration). Все то же самое, но тут нельзя сравнивать два разных enum class (но можно внутри одного). Так же для вызова надо исп. `::`:
```cpp
/* добавление "class" к enum определяет перечисление с ограниченной областью видимости, вместо стандартного "глобального" перечисления */
enum class Fruits 
{
	LEMON, // LEMON находится внутри той же области видимости, что и Fruits
	Kiwi,
	Vlad /* в случаии enum class не будет конфликта имен с Fruits из за локальной видимости. Если бы это были обычные enum, был бы конфликт из за Vlad */
};
 
enum class Colors
{
        PINK, // PINK находится внутри той же области видимости, что и Colors
        GRAY,
	Vlad  
};
 
Fruits fruit = Fruits::LEMON; // примечание: LEMON напрямую не доступен, мы должны использовать Fruits::LEMON
Colors color = Colors::PINK; // примечание: PINK напрямую не доступен, мы должны использовать Colors::PINK
	
if (fruit == color) 
/* ошибка компиляции, поскольку компилятор не знает как сравнивать разные типы: Fruits и Colors. Но можно сранивать напр. Fruits::LEMON и Fruits::Kiw; */
	std::cout << "fruit and color are equal\n";
 else
        std::cout << "fruit and color are not equal\n";
}
```

#### Зачем это надо?
Для удобного ведения программы, документации и вместо магических чисел: 
```cpp
/* возможные ошибки при чтении файла и соответсвующие им флаги */
enum ParseResult
{
    SUCCESS = 0,
    ERROR_OPENING_FILE = -1,
    ERROR_PARSING_FILE = -2,
    ERROR_READING_FILE = -3
};
 
ParseResult readFileContents()
{
    if (!openFile())
        return ERROR_OPENING_FILE;
    if (!parseFile())
        return ERROR_PARSING_FILE;
    if (!readfile())
        return ERROR_READING_FILE;
 
    return SUCCESS; 	// если всё прошло успешно
}

/* Основное тело программы */
if (readFileContents() == SUCCESS)
    {
    // Всё прошло успешно -> Делаем что-нибудь
    }
else
    {
    // Выводим сообщение об ошибке
    }
```
    
### Struct (a public class)
Essentially, it is a class but less secure, since:
1. Members of a class are private by default and members of a struct are public by default.
2. When deriving a struct from a class/struct (inherit), default access-specifier for a base class/struct is public. And when deriving a class, default access specifier is private.    

**Используйте ключевое слово struct для структур, используемых только для хранения данных. Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.**   

Как и любой другой тип данных его можно передавать ф-йии и возвращать.     
**Синтаксис**  
```cpp
struct Person{                                 // initialisation of a struct
    string name;                               // these are publicly accessible
    string lastname;			       // переменные структур - поля структур
    int age;
/* Можно делать default присвоение. Их надо ставить в конце, чтобы при инициализации их не переписать, оставив
объявленные без данных. Для них не работает uniform инициализация (способ 3) */
//    double salary = 4000;
    
}
vector<Person> staff;                          //create vector of Person(s)
staff.push_badck({"Ivan","Ivanov", 24});       //initialisation of a instance of Person
staff.push_badck({"Petr","Petrov", 100});
cout << staff[0].name;                         //prints "Ivan". Calling a variable of a stuct
```
**Присвоение значений полям**
```cpp
Person vasya;			// создаем example vasya структуры person
/* 1й способ: объявляем и присваиваем значение каждому полю вручную */
vasya.name = 'Vasya';                            
vasya.lastname = 'Pupkin';			       
vasya.age = 32;

/* 2й способ: инициализация структуры с параметрами */
Person john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james = { 6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 3й способ:  инициализацию uniform (C++ 11 и выше) */
Person john { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james { 6, 29 }; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 4й способ: объявили, а потом присвоили используя список инициализаторов (С++ 11 и выше)*/
Person john;
john = { 5, 27, 45000.0 }; // {} - это список инициализаторов
```
**Вложенные структуры**
```cpp
struct Employee
{
    short id;
    int age;
    float salary;
};
 
struct Company
{
    Employee CEO; 				// Employee является структурой внутри структуры Company 
    int numberOfEmployees;
};
 
Company myCompany = {{ 3, 35, 55000.0f }, 7 };  // Инициализация {{stuct Employee}, numberOfEmployees}

myCompany.CEO.salary 				// Обращение к вложенной структуре
```
**Размер**   
Обычно это сумма размеров его полей + несколько байт, которые добавляет компилятор для своей внутренней работы. 

---
### Классы
**Спецификатор доступа** определяет, кто имеет доступ к членам этого спецификатора. Eсть 3 уровня доступа:
- `public:` делает члены открытыми
- `private:` делает члены закрытыми
- `protected:` открывает доступ к членам только для дружественных и дочерних классов    
По умолчанию у классов спецификатор private, а у структур public. *Контроль доступа работает на основе класса, а не на основе объекта*. Это означает, что когда метод имеет доступ к закрытыми членам класса, то он может обращаться к закрытым членам любого объекта этого класса:
```cpp
class DateClass // члены класса являются закрытыми по умолчанию 
{
	int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
public:
	void copyFrom(const DateClass &b)
	{
		// Мы имеем прямой доступ к закрытым членам объекта b
		m_day = b.m_day;
		m_month = b.m_month;
		m_year = b.m_year;
	}
}

int main()
{
DateClass date;
date.setDate(12, 11, 2018); // ок, так как setDate() имеет спецификатор доступа public
	
DateClass copy;
copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
/* была создана копия экземпляра date и сохранена в copy */
}
```
**Функция доступа (Access functions)** — это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. Функции доступа обычно бывают двух типов:
- **Геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса.
- **Сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.

**Память**. Классы, структуры, энумераторы - это тип данных, поэтому при объявлении типа данных не выделятеся память (подобно тому, что память не выделяется встроеным типам данных, например, int). Память выделится при объявлении экземпляра этого класса. 

#### Конструктор
**Конструктор** — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определённый файл или базу данных). В отличие от обычных методов, конструкторы имеют определённые правила по поводу их имён: 
1. Конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры).
2. Конструкторы не имеют типа возврата (даже void-а).   
```cpp
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    Fraction() // конструктор по умолчанию (default constructor)
    {
         m_numerator = 0;
         m_denominator = 1;
    }
 
    // Конструктор с двумя параметрами, один параметр имеет значение по умолчанию
    Fraction(int numerator, int denominator=1)
    {
        assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
    }
 }
Fraction empty; // вызов Fraction(0, 1) - конструктора по умолчанию
Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)
Fraction seven(7); // вызывается конструктор Fraction(int, int), второй параметр использует значение по умолчанию
```
В примере выше **конструктор по умолчанию (default constructor)**, который будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который будет вызываться, если мы предоставим значения. Эти два конструктора могут мирно существовать в одном классе благодаря перегрузке функций. Фактически, вы можете определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры (учитывается их количество и тип). Однако в этом случаи проще использовать один конструктор с параметрами по-умолчанию: `Fraction(int numerator=0, int denominator=1)`.
```cpp
 Fraction(int numerator=0, int denominator=1)
{
	assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
}
// любая из инициализаций сработает соответствующим образом
Fraction drob; // вызов Fraction(0, 1)
Fraction seven(7); // вызов Fraction(7, 1)
Fraction sixTwo(6, 2); // вызов Fraction(6, 2)
```
Если ваш класс не имеет других конструкторов, то C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют **неявным конструктором (implicitly generated constructor)**.
```cpp
// что пишем и видим мы
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
};
// что видит компилятор
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
 
public:
    Date() // implicitly generated constructor
    {
    }
};
```
**Вложенные классы**. Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. *Это произойдёт до того, как тело конструктора выполнится*.    

---

## Helpful functions
- `static_cast<type2>(variable_type1)` - переводит variable_type1 в type 2.
- `typeid()` (находится в заголовочном файле typeinfo(#include <typeinfo>) показывает тип объекта: `typeid(variable).name()`.
- `sizeof(data_type)` - вернет размер типа данных (на данной компьютере/системе/компиляторе).   
Если число большего размера, чем переменная, то будет **переполнение**: отбросятся первые невмещающиеся биты: 
```cpp
int main()
{
    unsigned short x = 65535; // наибольшее значение, которое может хранить 16-битная unsigned переменная
    std::cout << "x was: " << x <<l; 
    x = x + 1; // 65536 - это число больше максимально допустимого числа из диапазона допустимых значений. Следовательно, произойдёт переполнение, так как переменнная x не может хранить 17 бит
    std::cout << ", x is now: " << x << std::endl;
}
```
Выйдет: `x was: 65535, x is now: 0` т.к. 65 535 в двоичной системе это 1111 1111 1111 1111, 65 536 представлено в двоичной как 1 0000 0000 0000 0000 (занимает 17 бит!). Обрезается 1й бит (т.е. 1), остается 0000 0000 0000 0000 т.е. 0. *Если из `unsigned short x = 0` вычесть 1, то будет 65 535* (т.е. на границе счетчик (range: 0 - 65 535) прокручивается в обе стороны).

--- 

# Chapter 6 Control Flow
Main flow control statements:   
- **halt** - statement that tells the program to quit running immediately. (напр., `exit()`, `break;`).
- **Jump** - causes the CPU to jump to another statement. (`goto`, `break`, and `continue` keywords, любая не main() ф-циия т.к. при вызове CPU прыгает к ее началу).
- **Conditional branches** - statement that causes the program to change the path of execution based on the value of an expression (`if-else`, `switch`).
- **Loops** - cause the program to repeatedly execute a series of statements until a given condition is false.
- **Exceptions** - a mechanism for handling errors that occur in a function. If an error occurs in a function that the function cannot handle, the function can trigger an exception. This causes the CPU to jump to the nearest block of code that handles exceptions of that type.
## Branches (Ветвление)
### if else 
```cpp
if (bool){
body}
else{
body}
```
- Может сравнивать строки (лексикографический, т.е. как в словаре): "a" < "aa" < "ab" < "aba" и т.д. (т.е. чем раньше по славорю, тем меньше строка. Строка сравнивается последовательно по каждой букве. При равных условиях, чем длинее строка, тем она больше)
- Сравнивает векторы аналогичным образвом:
```cpp
vector<int> nums1 = {1,2,3};     // nums2 > nums3 > nums1
vector<int> nums2 = {1,3,4};
vector<int> nums3 = {1,2,3,4};
if(nums3<nums2){
    cout << "more" << endl;
}
else{
    cout << "less" << endl;
}
``` 
Также есть упрощенная форма для вложенных if-else:
```cpp
// will check condition 1, then condition 2, then else
if (condition 1){
body 1}
else if(condition 2){	// аналогично elif в python
body 2}
else {
body3}
```

### Switch
Это способ ветвления по значению **integral data type** (т.е. char, short, int, long, long long, or enum):
```cpp
int x;
std::cin >> x;			// пусть будет 2
switch (x)		
{
   case 1: 			// Does not match -- skipped
       std::cout << 1 << '\n';
       break;
   case 2: 			// Match!  Execution begins at the next statement
       std::cout << 2 << '\n';  // Execution begins here
       break; 			// Break terminates the switch statement
   case 3:
   case 4:			// выполнистся код ниже при успловии x= 3 или 4
       std::cout << "3 or 4" << '\n';
       break;
   default:
       std::cout << 5 << '\n';
       break;
}
// Execution resumes here
```
Тут `x` проверсяется на равенсво стейтменту послу `case`, когда они совпали, то воспроизводится код ниже. Если не было совпадений, то воспроизводится код после `default`. При этом, если несколько `case` идут подряд (как для 3 и 4 в примере), то они работают как единый case (т.е. код выполнится при совпаденнии с любым из них).   

**Execution halt**   
В switch не используются блоки ({}) - отсюда странные условия выхода из case. Как только x совпал с case, выполнится весь код идущий за ним (включая любые ниже идущие case) (называется **fall-through**):
```cpp
switch (2)
{
   case 1: 			// Does not match
       std::cout << 1 << '\n';  // skipped
   case 2: 			// Match!
       std::cout << 2 << '\n';  // Execution begins here
   case 3:
       std::cout << 3 << '\n';  // This is also executed
   default:
       std::cout << 5 << '\n';  // This is also executed
}
```
Выполение внутри switch прирвется только после: 1) конец всего блока switch (после default), 2)`break`, 3)`return`. Поэтому под кодом case должны всегда стоять либо break, либо return.

**Scopes**   
Весь блок switch имеет единую область видимости. Поэтому, если объявить переменную в `case 1` (который не будет выполнен), а определить ее в `case 2` (который будет выполенен), то все выполнится:
```cpp
switch (2)
{
    int a; 		// okay, declaration is allowed before the case labels
    int b = 5; 		// illegal, initialization is not allowed before the case labels
 
    case 1:
        int y;		// okay, declaration is allowed within a case
        y = 4; 		// okay, this is an assignment
        break;
 
    case 2:
        y = 5; 		// okay, y was declared above, so we can use it here too
        break;
 
    case 3:
        int z = 4; 	// illegal, initialization is not allowed within a case
        break;
}
```
Т.к. объявление - это выделение памяти для переменной при компиляции, то объявленной переменной в любом месте (под любым case и до них) может пользоваться весь блок (например, переменными `a` и `y`). Однако, определение переменной производится на этапе выполнения, и тут уже нужно зайти в какой либо case. Тогда при инициализации (напр., `int z = 4`), копилятор должен выделить память под z, но еще неизвестно зайдет ли программа в `case 3` - поэтому это действвие запрещенно.

## Halts and jumps
### goto 
`goto placeFlag` - оператор, который заставляет CPU выполнить переход из одного участка кода к placeFlag (осуществить прыжок).
```cpp
	double z;
tryAgain: 					// это лейбл
	std::cout << "Enter a non-negative number: "; 
	std::cin >> z;
 
	if (z < 0.0)
goto tryAgain; 					// а это оператор goto 
 	std::cout << "The sqrt of " << z << " is " << sqrt(z) << std::endl;
```
- У goto - **область видимости функции** (т.е. goto и соответствующий лейбл (placeFlag) должны находиться в одной и той же функции.    
- Нельзя перепрыгнуть вперёд через переменную, которая инициализирована в том же блоке, что и goto:
```cpp
goto skip; // прыжок вперёд недопустим
    int z = 7;
skip: // лейбл
    z += 4; // какое значение будет в этой переменной? Она даже не определена
```

### break and continue
`break` - закончивает выполение блока {}. Если это switch или loop, то на этом преращается выполнение цикла, а CPU переходит на строку следующую сразу за ним (вне цикла).    
`continue` - оператор перемещающий CPU к концу блока. В случаии switch - это просто его конец. В случаии loop - это конец данной итерации цикла, после этого начнется следующая итерация. Нужно быть внимтельным при использовании continue и while (а также for(;condition;)) где счетчик в теле цикла: если continue перепрыгнет инкримент счетчика, то получится бесконеный цикл:
```cpp
while (count < 10)
	{
		if (count == 5)
			continue; 		// переходим в конец тела цикла
		std::cout << count << " ";
		++count;			// перепрыгнули инкримент счетчика
	// Точка выполнения после оператора continue перемещается сюда. Цикл стал бесконеным
	}
```
В этом случаии лучше использовать do-while:
```cpp
do
	{
		if (count == 5)
			continue; 		// переходим в конец тела цикла 
		std::cout << count << " ";
		// Точка выполнения после оператора continue перемещается сюда
	} while (++count < 10);			// инкремент счетчика находится вне тела цикла 
```

## loops
- `break;` - выход из цикла  
### for loop
1. `for (int n=10; n>0; n--){}` - general view

**Особенности**   
- Можно определить for только с успловием (`for(; condition; )`), если счетчик объявлен вне цикла и есть его инкремент/декремент(внутри цикла): 
   ```cpp
	int count = 0;				// счетчик объявлен вне цикла
	for (; count < 10; )
	{
		std::cout << count << " ";
		++count;			// инкремент/декремент счетчика контролирует цикл
	}
   ```
- Можно делать циклы по нескольким переменным: 
   ```cpp
   for (int aaa = 0, bbb = 9; aaa < 10; ++aaa, --bbb)
		std::cout << aaa << " " << bbb << std::endl;	
   /* вывод будет 0 9 / 1 8 / 2 7 / 3 6 / etc */
   ```
- У оператора `for` область видимости ограничена самим циклом (т.е. счетчики `aaa` и `bbb` будут уничтожены при выходе из цикла (полного цикла, а не каждой итерации как у `while`). (Однако, в старых версиях счетчики не удалялись после цикла).

2. **foreach loop** (для C++ 11 и выше)
Это специальный цикл for для контейнерова(массивы, строки и т.д.): `for (data_type element: container){}`. Каждый обработанный элемент массива копируется в переменную element. Поэтому внутри тела массива можно получить значение элемента без индексирования (оно в foreach не поддерживается). Можно сделать data_type = auto (`for (auto c: container){}`) - компилятор сам выберет нужный тип.

    ```cpp
    vector<int> nums= {1,2,3};
    string hw = "Hello world!"
    for (int c: nums){cout << c << ",";}
    for (char c: nums){cout << c << ",";}
    ```
Т.к. элемент массива только копируется в переменную element надо которой происходит действия внутри тела цикла, то сами элементы не могут быть изменены. Так же, если элемент очень большой (например, массива длинных строк), то его копия затратна. Можно "перебирать" элементы по ссылке (подобно передачи ссылке в ф-цию): 
```cpp
for (auto &element: array) // символ амперсанда делает element ссылкой на текущий элемент массива, предотвращая копирование
        std::cout << element << ' ';
```
Если же при этом надо убедиться, что элемент не изменится, то нужно использовать константный указатель (`for (const auto &element: array)`).

**foreach должен знать длинну контейнера**. Поэтому через него нельзя выводит динамические массивы и массивы переданные через *расподания в указатель*:
```cpp
int sumArray(int array[]) 		// array - расподается в указатель
{
    int result = 0;
    for (const auto &number : array) 	// ошибка компиляции, размер массива неизвестен
        result += number;
 
    return sum;   
}
```

### while и while do
1. `while(bool) {body}` - сначала проверяет условие, а затем выполняет.  
2. `do {body} while (bool);` - сначала выполняет, а потом проверяет условие.

**Особенности**   
Поскольку тело цикла обычно является блоком, и поскольку этот блок выполняется по новой с каждым повтором, то любые переменные, объявленные внутри тела цикла, создаются, а затем и уничтожаются по новой. Например:
```cpp
int result = 0;		// result определенн вне блока {} -> будет жить после всех циклов
while (count <= 6) 	// итераций будет 6 
{
	int z; 		// z создаётся здесь по новой с каждой итерацией
        std::cout << "Enter integer #" << count << ':';
        std::cin >> z;
 
        result += z;
	++count;	// Увеличиваем значение счётчика цикла на единицу
} 			// z уничтожается здесь по новой с каждой итерацией
```
---

# Chapter 7 Functions
## Термины
**Параметр функции (parameters)** (или ещё «формальный параметр») — это переменная, объявленная в объявлении функции:
```cpp
void boo(int x); // объявление (прототип функции). x - это параметр
 
void boo(int x) // определение (также объявление). x - это параметр
{
}
```
**Аргумент (arguments)** (или ещё «фактический параметр») — это значение, которое передает в функцию вызывающий объект (caller):
```cpp
boo(7); // 7 - это аргумент, который передаётся в параметр x
boo(y+1); // выражение y+1 - это аргумент, который передаётся в параметр x
```
Когда функция вызывается, все параметры функции создаются как переменные, а значения аргументов копируются в параметры.     
**Передача аргумента по значению (arguments by value)**. Когда аргумент передаётся по значению, то его значение копируется в параметр функции. По умолчанию аргументы в C++ передаются по значению.

## Общий синтаксис
```cpp
    int lcd (int a, int b){
	if (a%b == 0) return b; 	// возврат, когда мы довольны (нашли b)
	else lcd(b, a%b);		// вызов рекурсией
``` 

### ``` int main() ```  
Почему нужно возвращать значения обратно в операционную систему? Дело в том, что возвращаемое значение функции main() является кодом состояния, который сообщает операционной системе о том, успешно ли было выполнение программы или нет. Обычно, возвращаемое значение 0 (ноль) означает что, всё прошло успешно, тогда как любое другое значение означает неудачу/ошибку.  
Обратите внимание, по стандартам C++ функция main() должна возвращать целочисленное значение. Однако, если вы не укажете return в конце функции main(), то компилятор возвратит 0 автоматически, если никаких ошибок не будет. Но рекомендуется указывать return в конце main() и использовать тип возврата int для функции main().	

### Явно указываеся возвращаемый тип: `void` (ничего, нельзя в main()), `int`, `vector<int>`, etc: 
```cpp
void returnNothing()
{
    std::cout << "Hi!" << std::endl;
    // эта функция не возвращает никакого значения, поэтому оператор return здесь не нужен
}
 
int main()
{
    returnNothing(); // функция returnNothing() вызывается, но обратно в main() ничего не возвращается
 
    std::cout << returnNothing(); // ошибка: эта строчка не скомпилируется. Вам нужно будет её закомментировать
    return 0;
}
```

## Прототип функции  
Перед любым вызовом функция должна быть **определена** (т.е. описана). Если по какой-то причине ее нельзя определить раньше вызова, то сначала ставим ее **прототип**:  
```cpp
int add(int x, int y); // предварительное объявление функции add() (используется её прототип)
```

## **Аргументы**
### Передача по значению
- При вызове функции, все её параметры создаются как локальные переменные, а значение каждого из аргументов копируется в соответствующий параметр (локальную переменную). Этот процесс называется *передачей по значению*. При вызове в функцию передается копия передаваемой переменной, так что ее нельзя изменить внутри функции:
```cpp
    int funct(int a)
    {
    a = 100100;       //меняет только локальную копию, но не сам x
    return a;
    }
    
    int main()
    {
    int x = 10;
    funct(x);         //сюда передается копия x, не сам x
    cout << x;        //покажет x = 10 
    }
```
Рекомендуюется только при передаче **фундаментальных типов данных и перечислителей**, когда предполагается, что функция не должна изменять аргумент.

### Передача аргумента по ссылке
`int funct(int& a)` вместо копирования перемнной a в аргументы ф-ции, ей передается ссылка (псевдоним) на сам аргумент. Таким образом можно менять этот аргумент внутри блока ф-ции и эти изменения сохранятся после выхода из него. Тк работа с ссылками ничем не отличается от работы с переменной (синтаксически), то все действия внутри ф-ции будут производиться аналогично действиям над переменной.
```cpp
void addOne(int &x) // x - это переменная-ссылка
{
    x = x + 1;
} // x (ссылка) уничтожается здесь, но сохраненная в ней переменная изменилась
//  вызов ф-ции происходит так же как и вызов "по значению"
int x = 5;
addOne(x)
```

#### Константные ссылки
`void boo(const int &y) `    
Неконстантные ссылки могут ссылаться только на неконстантные l-values (например, на неконстантные переменные), поэтому параметр-ссылка не может принять аргумент, который является константным l-value или r-value (например, литералом или результатом выражения). Однако, константные ссылки могу принять *любые данные* (включая l-values, константные l-values и r-values). Также, они позволяют удостовериться, что значение аргумента не будет измененно.     

#### Возвращаемое значение ф-ции как аргумент другой ф-ции
`void funct_one(funct_two())` - в этом случаии возвращаемое значение ф-ции funct_two передается внешней ф-ции funct_one в качетсве аргумента. Это возможно только в случаи, если внешняя ф-ция принимает только константную ссылку в качестве аргумента (т.е. `void funct_one(const int& a)`.


Передача по ссылке рекомендуется при: 1) **передаче структур или классов** (используйте const, если нужно только для чтения); 2) когда нужно, чтобы функция изменяла значение аргумента; 3) При вызове ф-ции, когда ее аргумент является возвращаемым значением другой ф-ции (напр., `void funct_one(funct_two())`).


### Передача аргумента по адресу (указателю)
В этом случаии ф-ция принимает указатель, а аргумент должен быть адресом (т.е. его на него надо подействовать оператором `&` (address-of)). Внутри ф-ции параметр обрабатывается как указатель (он и есть указатель):
```cpp
void boo(int *ptr)				// принимает указатель
{
    *ptr = 7;					// обрабатывается как указатель 
}
 
int main()
{
    int value = 4;
 
    std::cout << "value = " << value << '\n';	// выведет 4
    boo(&value);				// передаем адрес переменной value
    std::cout << "value = " << value << '\n';	// выведет 7
}
```

- При передаче аргумента по адресу в переменную-параметр функции копируется адрес из аргумента. В этот момент параметр функции и аргумент указывают на одно и то же значение.
- Если параметр функции затем разыменовать для изменения исходного значения, то это приведёт к изменению значения, на которое указывает аргумент, поскольку параметр функции и аргумент указывают на одно и то же значение!
- Eсли параметру функции присвоить другой адрес, то это никак не повлияет на аргумент, поскольку параметр функции является копией, а изменение копии не приводит к изменению оригинала. После изменения адреса параметра функции, параметр функции и аргумент будут указывать на разные значения, поэтому разыменование параметра и дальнейшее его изменение никак не повлияет на значение, на которое указывает аргумент.     

#### Передача массива в качестве аргумента
Обычные (не динамические) массивы автоматически передаются по указателю (т.е. **распадаются** в указатель) (напр., `int funct(int array[])` тоже самое, что и `int fucnt(int* array)`). Внутри ф-ции параметр (те массив) синтаксически ведет себя как массив, но обрабатывается как указатель. Однако, при распадании в указатель массив меняет тип данных с `int[4]` (тип данных массива, который знает адрес первого элемента и свою длинну) на `int *` (просто адрес первого элемента). В связи с этим, для работы с массивом полезно передать в ф-цию длинну массива:
```cpp
void changeArray(int *some_array, int array_size)
{
    if (array_size > 3){
        std::cout << some_array << std::endl;		// выведет: 0x6afee0 (тип: `Pi` - т.е. pointer int)
        std::cout << *some_array << std::endl;		// выведет: 5
        std::cout << some_array[0] << std::endl;	// выведет: 5

        some_array[2] = 2000;
    }
}

int main()
{
int array[4] = { 5, 8, 6, 4 };
    std::cout << "Element 3: " << array[2]<< std::endl;	// выведет: 6
    changeArray(array, 4);
    std::cout << "Element 3: " << array[2];		// выведет: 2000
}
```

Т.к. при передаче массива он разименновываетс в указатель, то внутри ф-ции `my_array` - это просто указатель. Для него нельзя использовать foreach loop, т.к. указатель, а не контейнер, и для него неизвестен размер.

```cpp
void array_killa(int my_array[])
{
	for (int a : my_array)		// не будет компилироваться!
		std::cout << a << std::endl;
}

int main()
{
	int my_array[] = { 1,2,3,4,5,6,7,8,9 };
	array_killa(my_array);
}

```
Передача по адресу рекомендуется при: **передаче обычных массивов** (если нет никаких проблем с тем, что массивы распадаются в указатели при передаче).

#### Это всего лишь копия
Когда указатель передаётся в функцию по адресу, то значение этого указателя (адрес, на который он указывает) копируется из аргумента в параметр функции. Другими словами, указатель передаётся по значению! Если изменить значение параметра функции, то изменится только копия, исходный указатель-аргумент не будет изменён. Например,
```cpp
void setToNull(int *tempPtr)
{			/* Мы передали сюда адрес x (те указатель ptr) и скоприровали в указатель tempPtr. 
			Теперь на адрес x указывают 2 указателя: ptr и tempPtr */
    &tempPtr  = 100; 	// теперь x=100, тк мы разименовали указатель и изменили значение
    tempPtr = nullptr;  /* теперь tempPtr указаывает на 0, но адрес x от этого не изметинтся 
    			т.к. tempPtr - это копия адреса и все действия тут делаются над копией */
} 			// копия tempPtr уничтожена
int x =5;
int *ptr = &x;
setToNull(ptr); // передали адрес переменной x
```
Если надо, чтобы указатель был передан не по значению, как в примере выше, то надо передать указатель по ссылке (т.е. `void setToNull(int *&tempPtr)`). В этом случаии в ф-цию передасться сам указатель (адрес), а не его копия.

### read only (const) pass
Часто имеет смысл передать по ссылке объект (чтобы не копировать его), но при этом надо убедится что он не будет изменен (например случайно). В этом случаии надо передавать объект с префиксом `const`. Если объект попытаются изменить внутри ф-ции, то произойдет ошибка компиляции. 
```cpp
void funct(const int array)			// передача по указателю на const
// this_dude is an innstance of Dude class
void funct_two(const Dude& this_dude)		// передача по const ссылке
```
В случаи class member functions передача константной ссылки аналогична следующей записи `type funct_name() const`:
```cpp
void funct_two(Dude& this_dude) const
// то же самое, что и 
void funct_two(const Dude& this_dude)
```
**Правило:** При передаче аргументов по ссылке (в случаии массивов, указателю) всегда используйте константные ссылки, если вам не нужно, чтобы функция изменяла значения аргументов.    

### Страшная правда об аргументах ф-ций
Ссылки на самом деле реализуются с помощью указателей. Это означает, что передача по ссылке является просто передачей по адресу. И чуть выше мы говорили, что передача по адресу на самом деле является передачей адресу по значению (а передача адреса по ссылке - это передача адреса по адресу (sick!) )! Из этого следует, что C++ действительно передает всё по значению!

### Default arguments (параметры по умолчанию)
```cpp
void printValues(int a=10, int b=11, int c=12)
{
    std::cout << "Values: " << a << " " << b << " " << c << '\n';
}
// все вызовы ок
printValues(3, 4, 5);	// выведет: 3, 4, 5
printValues(3, 4);	// выведет: 3, 4, 12
printValues(3);		// выведет: 3, 11, 12
printValues();		// выведет: 10, 11, 12
```
**Правила**     
1. Все параметры по умолчанию в прототипе или в определении функции должны находиться справа:
```cpp
// не ок
void printValue(int a=5, int b); 
// ок
void printValue(int a, int b=5);
```
2. Если имеется более одного параметра по умолчанию, то самым левым параметром по умолчанию должен быть тот, который с наибольшей вероятностью (среди всех остальных параметров) будет явно переопределён пользователем.

## inline (встроенные ф-ции)
Одним из главных недостатков использования функций является то, что каждый раз, когда она вызывается, происходит расход ресурсов, что влияет на производительность программы. Это связано с тем, что ЦП должен хранить адрес текущей команды (инструкции или стейтмента), которую он выполняет (чтобы знать, куда нужно будет вернуться позже) вместе с другими данными. Затем точка выполнения перемещается в другое место программы. Дальше все параметры функции должны быть созданы и им должны быть присвоены значения. И только потом, после выполнения функции, точка выполнения возвращается обратно. Код, написанный «на месте» (т.е. внутри main()), выполняется значительно быстрее.

При этом, чем короче ф-ция и чем чаще ее вызывают, тем больше потери в памяти. При компиляции вашего кода, все **встроенные функции (ключевое слово `inline`)** раскрываются «на месте», то есть вызов функции заменяется копией содержимого самой функции. Например,
```cpp
inline int max(int a, int b)
{
    return a < b ? b : a;
}
// вместо этого 
int main()
{
    std::cout << max(7, 8) << '\n';
    std::cout << max(5, 4) << '\n';
    return 0;
}
// компилятор увидит это
int main()
{
    std::cout << (7 < 8 ? 8 : 7) << '\n';
    std::cout << (5 < 4 ? 4 : 5) << '\n';
    return 0;
}
```

**!** На самом деле, все современные компиляторы сами ставят `inline`, если это улучшает перфоманс. При том, компилятор может проигнорировать inline поставленный пользователем, если посчитате, что это не нужно. Таким образом, **не имеет смысла самому делать `inline`, так как компилятор знает лучше**.

## Function overloading (перегрузка ф-ций)
**Перегрузка функций** — это особенность в C++, которая позволяет определять несколько функций с одним и тем же именем, но с разными параметрами.
```cpp
//  ок, перегруженные ф-ции
int subtract(int a, int b);
int subtract(int a, int b, int c);
int subtract(double a, double b);

/* не ок, разницы в возвращаемом значении недостаточно, 
чтобы компилятор однозначно определил перегруженную ф-цию */
int getRandomValue();
double getRandomValue();

/* не ок, псевдоним на самом деле имеет все тот же тип данных, что и оригинал,
поэтому компилятор не может однозначно определить перегруженную ф-цию */
typedef char *string;
void print(string value);
void print(char *value);
```
Cтоит отметить, что параметры по умолчанию НЕ относятся к параметрам, которые учитываются при определении уникальности функции. Следовательно, следующее не допускается:
```cpp
// не ок
void printValues(int a);
void printValues(int a, int b=15);

// ок
void print(std::string string);
void print(char ch=' ');
/*Если пользователь вызовет просто print() (без параметров), 
то выведется пробел, что будет результатом выполнения  print(' ').*/
```

### Порядок сравнения параметров 
Как происходит сравнение поэтапно C++ пытается найти точное совпадение:
1.  C++ пытается найти точное совпадение. Это тот случай, когда фактический аргумент точно соответствует типу параметра одной из перегруженных функций. Например:
```cpp
void print(char *value);
void print(int value);
 
print(0); // точное совпадение с print(int)
```
Хотя `0` может технически соответствовать и `print(char *)` (как нулевой указатель), но он точно соответствует `print(int)`. Таким образом, `print(int)` является лучшим (точным) совпадением.

2.  Если точного совпадения не найдено, то C++ пытается найти совпадение путём дальнейшего неявного преобразования типов (автоматическое преобразование, те в "соседа" и больший тип: `short` -> `int`, `float`->`double`, `char`->`int`, etc)
```cpp
void print(char *value);
void print(int value);
 
print('b'); // совпадение с print(int) после неявного преобразования
```
В этом случае, поскольку нет print(char), символ b конвертируется в тип int, который затем соответствует print(int).

3. Если неявное преобразование невозможно, то C++ пытается найти соответствие посредством стандартного преобразования. В стандартном преобразовании: 1) любой числовой тип будет соответствовать любому другому числовому типу, включая unsigned (например, int равно float), 2) enum соответствует формальному типу числового типа данных (например, enum равно float), 3) нуль (0) соответствует типу указателя и числовому типу (например, 0 как char * или 0 как float).
```cpp
struct Employee; // определение упустим
void print(float value);
void print(Employee value);
 
print('b'); // 'b' конвертируется в соответствие версии print(float)
```
В этом случае, поскольку нет `print(char)` (точного совпадения) и нет `print(int)` (совпадения путём неявного преобразования), символ `b` конвертируется в тип `float` и сопоставляется с `print(float)`. *Так как все стандартные преобразования считаются равными, ни одно из них не считается выше остальных по приоритету* -> до этого лучше не доводить потому, что результаты непредсказуемы.

4. C++ пытается найти соответствие путём пользовательского преобразования. Например, мы можем создать класс W и в нём определить пользовательское преобразование в тип int:
```cpp
class W; // с пользовательским преобразованием в тип int
 
void print(float value);
void print(int value);
 
W value; // объявляем переменную value типа класса W
print(value); // value конвертируется в int и, следовательно, соответствует print(int)
```
Хотя value относится к типу класса W, но, поскольку тот имеет пользовательское преобразование в тип int, вызов print(value) соответствует версии print(int).

**!** Поскольку все стандартные и пользовательские преобразования считаются равными, то, если вызов функции соответствует нескольким кандидатам посредством стандартного или пользовательского преобразования, результатом будет **неоднозначное совпадение (Ambiguous matches)** (т.е. несколько совпадений). Например,
```cpp
void print(unsigned int value);
void print(float value);
// неоднозначности можно избежать, если использовать static_cast при передаче аргумента
 
print('b');
print(3.14159);
```
- В случае с `print('b')` C++ не может найти точного совпадения. Он пытается преобразовать `b` в тип `int`, но версии `print(int)` тоже нет. Используя стандартное преобразование, C++ может преобразовать `b` как в `unsigned int`, так и во `float`. Поскольку все стандартные преобразования считаются равными, то получается два совпадения.    

- А вот с `print(3.14159)` всё несколько запутаннее: большинство программистов отнесут его однозначно к `print(float)`. Однако, помните, что по умолчанию все значения-литералы типа с плавающей запятой относятся к типу `double`, если у них нет окончания `f`. 3.14159 — это тип `double`, а версии `print(double)` нет. Следовательно, мы получаем ту же ситуацию, что и в предыдущих случаях — неоднозначное совпадение (два варианта).

## Адрес ф-ции и указатель на нее
Указатели на функции полезны, прежде всего, когда вы хотите хранить функции в массиве (или в структуре) или когда вам нужно передать одну функцию в качестве аргумента другой функции.     

Ф-ции это особый тип данных и они имеют свой адрес в памяти. Например, ф-ция `int boo(int a)` имеет тип данных ф-ции принимающей int и возвращающей int. Ф-ция `int boo_two()` имеет тип данных ф-ции не принимающей ничего и возвращающей int. Таким образом, **ф-ции - это l-value**. Отсда следуют, что у них есть однозначный адрес (где хранится их кода) и на этот адрес можно создать указатель.   

Вызов ф-ции осуществляется через оператор `()`, а имена функций являются указателями на функции. Вызов происходит при действии оператором `()` на указатель (`имя_ф-ции()`). При вызове ф-ции CPU переходит по ее адресу и выполняет код внутри ф-ции, а потом возвращается назад на точку после вызова.
```cpp
int boo() 		// код функции boo находится в ячейке памяти 002B1050
{
    return 7;
}
 
int main()
{
    boo(); 		// переходим к адресу 002B1050
    std::cout << boo;	/* мы хотим вызвать boo(), но вместо этого мы просто выводим boo!
    Выведет: 002B1050 (хотя компилятор может сам конвертировать во что-то другое*/
    return 0;
}
```
Тк у ф-ции есть адерес, то для него можно создать указатель. При этом указатель должен точно соответствовать типу ф-ции. Если указатель не const, то ему можно присвоить адрес другой ф-ции такого же типа (те принимает такие же аргуметы по типу, кол-ву и возвращает такое же значение):
```cpp
// fcnPtr - это указатель на функцию, которая не принимает никаких аргументов и возвращает целочисленное значение
int (*fcnPtr)();
// fcnPtr_two -  константный указатель на такую же ф-цию
int (*const fcnPtr_two)();
/* не путать int const (*fcnPtr_two)(); Это указатель на функцию, которая возвращает const int. */
int (*fcnPtr3)(int); // это указатель на функцию, которая принимает int и возвращает int
```
Скобки вокруг `*fcnPtr` необходимы для соблюдения приоритета операций, в противном случае int `*fcnPtr()` будет интерпретироваться как предварительное объявление функции `fcnPtr`, которая не имеет параметров и возвращает указатель на целочисленное значение.    

### Инициализация и присвоение ф-ции указателем
```cpp
 int (*fcnPtr)() = fu; 	// fcnPtr указывает на функцию fu
 fcnPtr = bar;		// fcnPtr теперь указывает на функцию bar (имеет такой же тип данных, что и fu)
// не путать с 
fcnPtr = doo();		// fcnPtr - присваивает возвращаемое значение ф-ции doo, а не адрес
```
Можно вызывать ф-ции разыименовывая указатель на них. Можно раименовать явное и неявно. По сути, имя любой ф-ции - это указатель на нее, а при вызвое (через оператор `()`) он неявно разыменовывается.
```cpp
int boo(int a)
{
    return a;
}
 
int main()
{
    int (*fcnPtr)(int) = boo; // присваиваем функцию boo для fcnPtr 
    (*fcnPtr)(7); // вызываем функцию boo(7), через явное разыменование fcnPtr
    fcnPtr(7);	  // вызываем функцию boo(7), через неявное разыменование fcnPtr
    return 0;
}
```
Важно, что указатель это compile-time const, а **параметры по умолчанию** - это run-time const. Поэтому при вызове ф-ции через заименование указателя пораметры по умолчанию **не будут работать**.

### Передача ф-ции в качестве параметра ф-ции
Возможность передать ф-цию в качетсве параметра - это основная цель создания указателя на ф-цию. Например, при создании ф-ции с алгоритмом сортировки (`void selectionSort(int *array, int size)` ей можно передать ф-цию задающую способ сравниния чисел при сортироке (напр, `descending()` - по убыванию, `ascending()` - по возрастанию, `even_first()` - четные будут впереди и тд):
```cpp
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
{
/* опустим тело программы. Суть в том, что сюда передается ф-ция comparisonFcn, которая будет 
сравнивать 2 числа опреденным образом */
	 if (comparisonFcn(array[bestIndex], array[currentIndex])) // СРАВНЕНИЕ ВЫПОЛНЯЕТСЯ ЗДЕСЬ
	 	// если результат true, то двигаем число вверх по списку
}

bool ascending(int a, int b)
{
    return a > b; // меняем местами, если первый элемент больше второго
}
 
bool descending(int a, int b)
{
    return a < b; // меняем местами, если второй элемент больше первого
}
// пример многофункционального использования
int main()
{
    int array[8] = { 4, 8, 5, 6, 2, 3, 1, 7 };
 
    // Сортируем массив в порядке убывания, используя функцию descending()
    selectionSort(array, 8, descending);
    printArray(array, 8);
 
    // Сортируем массив в порядке возрастания, используя функцию ascending()
    selectionSort(array, 8, ascending);
    printArray(array, 8);
 
    return 0;
}
```
### Псевдонимы для указателей на ф-ции
Синтаксис указателей на ф-ции достаточно уродлив, поэтому имеет смысл использовать псевдонимы:
```cpp
// если такая ф-ция 
bool validate(int a, int b, bool (*fcnPtr)(int, int));

// два способа сделать спевдоним для bool (*fcnPtr)(int, int)
typedef bool (*validateFcn)(int, int); // validateFcn - псевдоним для типа данных bool(*)(int, int)
using validateFcn = bool(*)(int, int); // тоже самое (для C++11)

// теперь вызов ф-ции 
bool validate(int a, int b, validateFcn pfcn);
```

### std::function
В C++11 ввели более удобный синтаксис для работы с указателями на ф-ции: `std::function<bool(int, int)> fcn;` - указатель (имя fcn) на ф-цию принимающую два int и возвращающую bool.
```cpp
std::function<int()> fcnPtr; // объявляем указатель на функцию, который возвращает int и не принимает никаких параметров
fcnPtr = doo; // fcnPtr теперь указывает на функцию doo
std::cout << fcnPtr(); // вызываем функцию, как обычно
```

---

# Chapter 8 Files and project magement 

## Файлы 
### Добавление файла в проект
1. Файл добавляется в проект через IDE ( «File» -> «New» -> «File…» -> «C/C++ source»), а затес в вызывающем файле делается прототип вызываемой функции (т.е. просто объявление).
2. `#include "my_file.cpp"` - копирует my_file *целиком* сразу этой инструкции внутрь ф-ции, в которой выполнятеся инструкция. Поэтому так делать *плохо* (т.к. теряется весь смысл разбивать на файлы)! Инструкция `#include ..` нужна для headr files (см. ниже).

### Заголовочные файлы (header file) (`.h`)
Это файл состоящий из прототипов функций и все (технически, можно и определять ф-ции, но это табу!). При вызове (`#include ..`) записывает все своем содержимое (т.е. все прототипы) сразу за инструкцией и все портотипы оказываются в зоне видимости функции.
- `#include <iostrem>` - зывов header file из *стандартной библиотеки* ( 1. используются <> и 2. опущена .h)
- `#include "my_header.h"` - зывов *собственного* header file   
#### Содержимое
Header file состоит из 2х частей:
1. **директивы препроцессора**, в частности, header guards, которые предотвращают вызов заголовочного файла больше одного раза с одного и того же файла;
2. **содержимое заголовочного файла**: набор объявлений.   
```cpp
// Начинаем с директив препроцессора. ADD_H – это произвольное уникальное имя (обычно используется имя заголовочного файла)
#ifndef ADD_H
#define ADD_H
 
// А это уже содержимое заголовочного файла
int add(int x, int y); // прототип функции add() (не забывайте точку с запятой в конце!)

// Заканчиваем директивой препроцессора
#endif
```
#### Директивы препроцессора
**Препроцессор** лучше всего рассматривать как отдельную программу, которая выполняется перед компиляцией. При запуске программы препроцессор просматривает код сверху вниз, файл за файлом, в поиске директив. **Директивы** — это специальные команды, которые начинаются с символа # и НЕ заканчиваются точкой с запятой. Препроцессор проходит файл сверху вниз и игнорирует все инстрекции без #. Поэтому не важно где их писать (вначале файла, внутри функции и т.д.), он не видит границ у ф-ций.
- `#include <filename>` которая сообщает препроцессору искать файл в системных путях (standard library). `#include "filename"` - которая сообщает препроцессору искать файл в текущей директории проекта (собственный файл). Если его там не окажется, то препроцессор начнёт проверять системные пути и любые другие, которые вы указаны в настройках IDE. 
- `#define ` - создает макросы. **Макрос** — это правило, которое определяет конвертацию идентификатора в указанные данные. Есть два основных типа макросов: **макросы-функции** и **макросы-объекты**.	**Макросы-функции** ведут себя как функции и используются в тех же целях. Они считается опасным, и почти всё, что они могут сделать, можно осуществить с помощью простой (линейной) функции. **Макросы-объекты** можно определить одним из двух следующих способов:   
	`#define identifier` -  любое дальнейшее появление *identifier*  заменяется «ничем» (пустым местом)! 
	`#define identifier substitution_text` - любое дальнейшее появление *identifier* заменяется на *substitution_text*. (такое использование #define считается плохой практикой, т.к. замены будут в глобальной области видимости всей программы. Вместо этого лучше использовать const: `const int smth = 30` и по мере необходимости меня все в ней).
	```cpp
	#define MY_NUMBER 9
 
	std::cout << "My number is: " << MY_NUMBER << std::endl;  //Результат выполнения: "My number is: 9"
	```
- Директивы условия компиляции   
	`#ifdef` Директива #ifdef (англ. «if defined» = «если определено») позволяет препроцессору проверить, было ли значение ранее #define. Если да, то код между `#ifdef` и `#endif` скомпилируется. Если нет, то код будет проигнорирован. Например:
  	```cpp
	#define PRINT_JOE
	
	#ifdef PRINT_JOE                   //скомпилируется и выполнится
	std::cout << "Joe" << std::endl;  
	#endif
 
	#ifdef PRINT_BOB		   //поскольку PRINT_BOB не был #define, будет проигнорована (не скомпилируется)
	std::cout << "Bob" << std::endl;
	#endif
	```
	Директива `#ifndef` (англ. «if not defined» = «если не определено») — это полная противоположность #ifdef, которая позволяет 	проверить, не было ли значение ранее определено. В примере вышe: выполнится часть PRINT_BOB, так как PRINT_BOB ранее никогда 	 	 не был #define. PRINT_JOE не выполниться, так как есть #define PRINT_JOE.   
	
	- В принципе, т.к.  препроцессор игнорирует все кроме #, то не важно, где писать #define PRINT_JOE (внутри функции или вне). Однако, принято писать их вне функций для читабельности кода.
	- Директивы, определённые в одном файле кода, не влияют на директивы, определённые внутри других файлов этого же проекта (т.е. область видимости ограничена файлом).
#### header guards
Это конструкция из директив, которые предотвращают повторное подключение файла (и соответственно повторного определения функции/переменной). Например, в *main* - файле есть вызов *math.h* - файл и *geometry.h* (а в ней повторый вызов *math.h*. В итоге в *main* будет дважды скопированно содержимое *math.h*, что приведет к ошибке компиляции. Решение head guard:
```cpp
#ifndef UNIQUE_NAME_HERE		// код ниже выполнится ниже, только если UNIQUE_NAME_HERE не была определена (т.е. не было 
#define UNIQUE_NAME_HERE		// вызова #define UNIQUE_NAME_HERE), иначе проигнорирует
 
// основная часть кода 
 
#endif
```
Так, если UNIQUE_NAME_HERE не была определена, то код выполниться. При повторном вызове, UNIQUE_NAME_HERE уже определена и дальше код не пойдет (не будет второго вызова). Обычно UNIQUE_NAME_HERE называют по названтю файла +_H (напр, файл *math*: MATH_H: `#ifndef MATH_H`)

---

# Chapter 9 Scopes

## Scopes (Зоны видимости)  
Переменные, объявленные внутри функции, существуют только в ней (это касатеся и main()). Поэтому при вызове функции, в нее передаются копии переменных/объектов.  
```cpp
int add(int a, int b) // здесь создаются переменные a и b функции add()
{
   return a + b;
} // здесь a и b функции add() выходят из области видимости и уничтожаются
 
int main()
{
   int a = 7; // здесь создаётся переменная a функции main()
   int b = 8; // здесь создаётся переменная b функции main()
   std::cout << add(a, b) << std::endl; // значения переменных a и b функции main() копируются в переменные a и b функции add()
   return 0;
} // здесь a и b функции main() выходят из области видимости и уничтожаются
```
### Локальные переменные
**Локальные переменные** имеют **автоматическую продолжительность (время жизни)**: они создаются (и инициализируются, если необходимо) в точке определения и уничтожаются при выходе из блока.
```cpp
int main() // внешний блок
{
    int m(4); // переменная m создаётся и инициализируется здесь 
    { // Начало вложенного блока 
        double k(5.0); // переменная k создаётся и инициализируется здесь
	/* m видная в этом блоке и может быть исаользована. 
	   Но если создать m тут, то будет использована "местная" переменная */
    } // k выходит из области видимости и уничтожается здесь 
    // Переменная k не может быть использована здесь, так как она уже уничтожена!
} // Переменная m выходит из области видимости и уничтожается здесь
```
### Сокрытие переменных    
Подобно тому, как переменные во внутреннем блоке скрывают переменные с теми же именами во внешнем блоке, локальные переменные скрывают глобальные переменные с одинаковыми именами внутри блока, в котором они определены. Однако, с помощью оператора разрешения области видимости (::), компилятору можно сообщить, какую версию переменной вы хотите использовать: глобальную или локальную. Например:
```cpp
int value(4); // глобальная переменная

int main()
{
    int value = 8; // эта переменная (локальная) скрывает значение глобальной переменной
    value++; // увеличивается локальная переменная value, не глобальная 
    ::value--; // уменьшается глобальная переменная value, не локальная 
    // ::value - вызов из глобального пространства имен
 
    std::cout << "Global value: " << ::value << "\n";   // выйдет "Global value: 3"
    std::cout << "Local value: " << value << "\n";	// выйдет "Local value: 9"
    return 0;
} // Локальная переменная уничтожается
```
Многие разработчики добавляют к глобальным переменным префикс **g_** (“g” от англ. “global”). Таким образом можно убить сразу двух зайцев: определить глобальные переменные и избежать конфликтов имён с локальными переменными.   

### Глобальные переменные   
Глобальные переменные включаются в *глобальное пространство имен*. Если вы хотите сделать глобальную переменную внутренней (которую можно использовать только внутри одного файла) — используйте ключевое слово `static`. Если вы хотите сделать глобальную переменную внешней (которую можно использовать в любом файле программы) — используйте ключевое слово `extern`:
```cpp
#include <iostream>
 
static int g_x; // g_x - это статическая глобальная переменная и её можно использовать только внутри этого файла
extern double g_y(9.8); // g_y - это внешняя глобальная переменная и её можно использовать и в других файлах программы

int main()
{
    return 0;
}
```
По умолчанию, неконстантные переменные, объявленные вне блока, считаются внешними. Однако константные переменные, объявленные вне блока, считаются внутренними. Чтобы использовать инициализированную внешнюю глобальную переменную (`extern`) в другом файле, нужно там ее объявить. Например:
```cpp
/* int g_m; 
int g_n(3); - были ранее инициализированны в другом файле. */
extern int g_m; // предварительное объявление g_m. Теперь g_m можно использовать в любом месте этого файла  
 
int main()
{
    extern int g_n; // предварительное объявление g_n. Теперь g_n можно использовать только внутри main()
 
    g_m = 4;
    std::cout << g_n; // должно вывести 3
 
    return 0;
}
```
**Глобальные переменные это зло!**. Если их использовать то только так: 1) `static` переменная доступ к которой сделан ф-цией:
```cpp
static double g_gravity (9.8); // ограничиваем доступ к переменной только на этот файл
 
double getGravity() // эта функция может быть экспортирована в другие файлы для доступа к глобальной переменной
{
    return g_gravity;
}
```
2) Не использовать их в теле ф-ции, а вызывать их как аргументы:
```cpp
// static double g_gravity (9.8); - глобальная переменная
// Передайте возвращаемое значение из getGravity() в параметр gravity, если хотите использовать глобальную переменную gravity
double instantVelocity(int time, double gravity)
{
    return gravity * time;
}
```

---
### Функции  
Функции имеют такие же свойства связи, что и переменные. По умолчанию они имеют внешнюю связь, которую можно сменить на внутреннюю с помощью ключевого слова `static`:
```cpp
// Эта функция определена как static и может быть использована только внутри этого файла
// Попытки доступа к ней через прототип функции будут безуспешными
static int add(int a, int b)
{
    return a + b;
}
```
Предварительные объявления функций не нуждаются в ключевом слове extern. Компилятор может определить сам (по телу функции): определяете ли вы функцию или пишите её прототип.

### Static
Используется в двух случаях:
1) Внутреннийе глобальные переменные (видимые во всем файле, объявленные в его начале). (По стандарту начинается с `g_` : `g_name`.)
2) **Статические переменные** (По стандарту начинается с `s_` : `s_name`.). Статическая переменная (или ещё «переменная со статической продолжительностью») сохраняет своё значение даже после выхода из блока, в котором она определена. То есть она создаётся (и инициализируется) только один раз, а затем сохраняется на протяжении выполнения всей программы. Например ф-ция для генерации ID:
```cpp
int generateID()
{
    static int s_itemID = 0;
    return s_itemID++;
}

int main()
{
	cout << generateID();		// вернет 0
	cout << generateID();		// вернет 1
	cout << generateID();		// вернет 2
	return 0;
}
```
Прелесть в том, что s_itemID имеет локальную видимость видимость только внутри ф-ции  generateID, но не уничтожается при выходе (гораздо безопаснее чем глобальные переменные).

## namespace 
**Пространство имен (namespace)** - это область видимости в программе. Нужно, чтобы избежать конфликтов имен. Например, в iostream ф-ция `cout` - она в *namespace std*, если не сообщить компилятору, что это std, то он будет считать cout неизвестной ф-цией (т.е. я могу сделать свой cout).   

**Глобальное пространство имен** все глобальные переменные и функции (не static) определятся в глобальное пространство имен (оно одно на всю программу). 

1. **оператор разрешения области видимости (::)**(`std::cout`) он определяет пространство имен только в данном случаи (т.е. далее я могу создавать свои ф-ции с именами из std).    
2. **using**. Ее видимость определятся блоком: если команда написана внутри ф-ции, то пространсво имен доступно только внутри нее. Если в начале файла, то на весь файл (это касается и *объявления* и *директив*).
	- **«объявление using»** `using std::cout;`- сообщает компилятору, что cout следует обрабатывать как std::cout. Позволяет подключить только одну ф-цнию/переменную из пространства имен.
	- **«директивы using»**. `using namespace std;` - команда, которая поделючает пространство имен (std) во всем файле (т.е. все ф-цнии/переменные, далее я не могу создавать свои ф-ции с именами из std).  

**Объявлять/добавлять новые элементы из разных файлов и мест внутри файла в один namespace** можно: 
```cpp
/* file add.h */
namespace DoMath
{
    // Функция add() является частью пространства имён DoMath
    int add(int x, int y)
    {
        return x + y;
    }
}

/* file substract.h */
namespace DoMath
{
    // Функция subtract() является частью пространства имён DoMath
    int subtract(int x, int y)
    {
        return x - y;
    }
}
```
В этом случаи из 2х разных файлов добавили ф-ции в один namespace. Их вызов можно сделать через `DoMath::add(5,4);` (незабыть #include оба файла).

**Псевдонимы (aliases) и вложенные пространства имён**   
Одни пространства имён могут быть вложены в другие пространства имён. Например:
```cpp
namespace Boo
{
    namespace Doo
    {
        const int g_x = 7;
    }
}
 
int main()
{
    std::cout << Boo::Doo::g_x;
    return 0;
}

/* аналогично используя псевдонимы (aliases) */

namespace Foo = Boo::Doo; // Foo теперь считается как Boo::Doo (псевдоним)
 
int main()
{
	std::cout << Foo::g_x; // это, на самом деле, Boo::Doo::g_x
	return 0;
}
```

# Chapter 10 Other
## Использование слова static
1. Persistence: it remains in memory until the end of the program.
2. **(Scope)** File scope: it can be seen only withing a file where it's defined. Visibility: if it is defined within a function/block, it's scope is limited to the function/block. It cannot be accessed outside of the function/block.
3. **(Class)** Static members exist as members of the class rather than as an instance in each object of the class. So, this keyword is not available in a static member function. Such functions may access only static data members. **There is only a single instance of each static data member for the entire class**. *A static data member : class variable. A non-static data member : instance variable*. Static member function: it can only access static member data, or other static member functions while non-static member functions can access all data members of the class: static and non-static.
