# Chapter 15: Inheritance
## Общее
В C++ логика наследования потроена на принципе "является", те пусть есть класс Human(имеет age, name) и класс Employee (имеет age, name, id, salary). В этом случаии логично сделать Employee подклассом Human (те Employee является Human, тк у них совпадают поля age, name). Реализовывается это так: `ChildClassName :access_specifier ParetClassName` (`access_specifier`: `public`, `private` или `proteсted`) Например,
```cpp
class Human
{/*опустим его тело*/}

class Employee: public Human    //Employee наследует от класса Human (со спецификатором public)
{/*опустим его тело*/}
```

## Порядок построения дочерних классов
При наследовании Child класс не копирует поля и методы Parent класса. Вместо этого можно рассматривайь Child как класс, который состоит из двух частей: первая — Parent, вторая — Child. При этом у них свои отдельные поля, методы, конструкторы и декструкторы. Пусть, например, у нас есть следующие Parent и Child классы:
```cpp
class Parent
{
public:
    int m_id;                             //поля Parent
 
    Parent(int id=0)                      //констркутор Parent
        : m_id(id)
    {
        std::cout << "Parent\n";
    }
 
    int getId() const { return m_id; }     //методы Parent
};
 
class Child: public Parent                 //Child наследует от Parent
{
public:
    double m_value;                        //поле Child
  
    Child(double value=0.0)                //конструктор Child
        : m_value(value)
    {
        std::cout << "Child\n";
    }
 
    double getValue() const { return m_value; }
};
 
int main()
{
    std::cout << "!!!Instantiating Parent!!!:\n";
    Parent dParent;    // Создаем экземпляр класса Parent 
    
    std::cout << "!!!Instantiating Child!!!:\n";
    Child dChild;      // Создаем экземпляр класса Parent 
 
    return 0;
}

/* Будет выведено *******************************
!!!Instantiating Parent!!!:
Parent
!!!Instantiating Child!!!:
Parent    //те сначала выполнился конструктор Parent
Child     //потом выполнился конструктор Child
************************************************/
```
**Создаем экземпляр класса Parent**      
Что происходит:
1. выделяется память для объекта parent;
2. вызывается соответствующий конструктор класса Parent (если его нет, то компилятор вызовет конструктор по умолчанию);
3. список инициализации инициализирует переменные;
4. выполняется тело конструктора;
5. точка выполнения возвращается обратно в caller.

**Создаем экземпляр класса Child**
Что происходит: 
1. выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта класса Child);
2. вызывается соответствующий конструктор класса Child;
3. создаётся объект класса Parent с использованием соответствующего конструктора класса Parent (как указано выше). Если такой конструктор программистом не предоставлен явно, то будет использоваться конструктор по умолчанию класса Parent;
4. список инициализации инициализирует переменные класса Child;
5. выполняется тело конструктора класса Child;
6. точка выполнения возвращается обратно в caller.

### Инициализация членов родительского класса при наследовании
Для членов уникальных для Child класса (не наследованных) все инициализуется как обычно. Однако инициализация членов Parent класса имеет свои особенности: они всегда должны быть инициплизованны через список инициализации *используя конструктор класса Parent* (см. выше: шаг 3 создания экземпляра Child). Если у Parent нет подходящего конструктора, то компилятор сгенерирует сам, однако его повидение может не соответствовать ожиданиям, поэтому лучше самому написать хороший. Ниже представлены три варианта попытки инициализировать члены класса Parent при создании Child (1я правильная, 2я и 3я - неправильно!):    

1. 
    ```cpp
    // 1й пример (ОК!): используя список инициализации и конструктор Parent
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            : Parent(id), // вызывается конструктор Parent(int) со значением id!
                m_value(value)
        {
        }

        double getValue() const { return m_value; }
    };
    ```
    Тут все правильно, но нужно убедиться, что у Parent есть хороший конструктор. C++ запрещает дочерним классам инициализировать наследуемые переменные-члены родительского класса в списке инициализации своего конструктора. Другими словами, **значение переменной может быть задано только в списке инициализации конструктора, принадлежащего к тому же классу, что и переменная-член** (ошибка в примере 2). Тут так же не возникнет проблемы с доступом к членам Parent (они могут и, скорее всего, будут private), как в примере 3. Таким способом можно и нужно инициализировать члены Parent, как public, так и private.
2. 
    ```cpp
    //2й пример (ОШИБКА!): используя список инициализации и прямую инициализацию члена Parent
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            // Не сработает
            : m_value(value), m_id(id)
        {
        }

        double getValue() const { return m_value; }
    };
    ```
    Как было сказано выше, C++ запрещает инициализировать напрямую члены класса Parent. Для этого надо использовать конструктор. Таким образом не нарушается проблема инициализации private членов Parent класса. Инкапсуляция!

3. 
    ```cpp
    //3й пример (ОШИБКА!): используя тело конструктора
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            : m_value(value)
        {
            m_id = id;
        }

        double getValue() const { return m_value; }
    };
    ```
    До тела конструктора Child мы доходим уже после вызова конструктора Parent класса и списка инициализации Child (см. шаги выше). Это значит, что m_id уже был создан дефолтным конструктором Parent, а теперь в теле мы пытаемя его инициализировать, но мы не знаем, может он private. Вообще говоря, код скомпилируется, если m_id - public, но будет ошибка, если он private. В любом случаии - это плохой код!

### Цепочка наследований
#### Конструкторы
Пусть у нас есть Parent класса A, от него наследуют B. От B наследует C. В этом случаии цепочка расскручиваестя следующим образом: C вызывает конструктор для B, тот в свою очередь вызывает конструктор для A. 
```cpp
class A
{
public:
    A(int a)
    {
        std::cout << "Construct A" << std::endl;
    }
    ~A()
    {
        std::cout << "Destruct A" << std::endl;
    }
};
 
class B: public A
{
public:
    B(int a, double b)
    : A(a)
    {
         std::cout << "Construct B" << std::endl;
    }
    ~B()
    {
       std::cout << "Destruct B" << std::endl; 
    }
};
 
class C: public B
{
public:
    C(int a , double b , char c)
    : B(a, b)
    {
         std::cout << "Construct C" << std::endl;
    }
    ~C()
    {
        std::cout << "Destruct C" << std::endl;
    }
};

int main()
{
    { //construct C
        C c(1, 2.2, 'a');
    } //destruct C
}

/* Будет выведено **************
Construct A
Construct B
Construct C
Destruct C
Destruct B
Destruct A
*******************************/
```

#### Деструкторы
При уничтожении дочернего класса, каждый деструктор вызывается в обратном порядке построения классов: "изнутры-наружу". В примере выше, при уничтожении объекта класса С, сначала вызывается деструктор класса C, затем деструктор класса B, а затем уже деструктор класса A.

### Приведение (преобразование) классов
При наследовании возможно преобразование к родительскому типу (те Child -> Parent), но не наоборот (Parent -> Child нельзя). При этом сохраняется только срез (те часть класса родителя). Пусть, например, у нас есть родительский класса Person (поля: Name, Age) и наслединик Student (поля: Name, Age, University). Тогда,
```cpp
Student s("Alex", 21, "Oxford");
Person & l = s; 	// Student & -> Person & (ссылка на класс Person)
Person * r = &s; 	// Student * -> Person * (указатель на класс Person)
//объекты класса-наследника могут присваиваться объектам родительского класса:
Person p = s; // Person("Alex", 21); // инициализация копированием класса Person классом Student. вызывается конструктор копирования Person
```
При этом копируются только поля класса-родителя (срез). Т.е. в данном случае вызывается конструктор копирования `Person(Person const& p)`, который не знает про поле University.

## Спецификаторы наследования
### Спецификаторы доступа
Классы имеют 3 вида спецификаторов доступа: public, private и protected (имеет смысл лишь в контексте наследования). **Protected** - это спецификатор, который ведет себя как private (запрещает доступ к челенам извне), однако, когда класс наследуется, то Child класс имеет доступ к protected членам Parent. Еще раз, пусть у нас есть некоторый член в классе Parent (my_field). Если переменная имеет следующий спецификатор доступа, то:
1. `public` - Child имеет доступ к ней. Child также предоставляется к ней доступ извне: `child.my_field`.
2. `private` - Child не имеет доступ к ней. Child не может предоставит к ней доступ извне.
3. `protected` - Child имеет доступ к ней. Однако, Child *не может предоставит к ней доступ извне*.

Например,
```cpp
class Parent
{
public:
    int m_public;           // доступ к этому члену открыт для всех объектов
private:
    int m_private;          // доступ к этому члену открыт только для Parent
protected:
    int m_protected;        // доступ к этому члену открыт для Parent и для дочерних классов (Child)
};
 
class Child: public Parent
{
public:
    Child()
    {
        m_public = 1;       // МОЖНО: доступ к открытым членам родительского класса из дочернего класса
        m_private = 2;      // НЕЛЬЗЯ: доступ к закрытым членам родительского класса из дочернего класса
        m_protected = 3;    // МОЖНО: доступ к защищённым членам родительского класса из дочернего класса
    }
};
 
int main()
{   // При доступе извне дочернего класса
    Parent parent;
    parent.m_public = 1;    // МОЖНО: доступ к открытым членам класса извне
    parent.m_private = 2;   // НЕЛЬЗЯ: доступ к закрытым членам класса извне
    parent.m_protected = 3; // НЕЛЬЗЯ: доступ к защищённым членам класса извне
    
    Child child;
    child.m_public = 4;     // МОЖНО: доступ к открытым членам класса извне
    child.m_private = 5;    // НЕЛЬЗЯ: доступ к закрытым членам класса извне
//  child.m_protected = 6;  // НЕЛЬЗЯ: доступ к защищенным членам класса извне
}
```
### Типы наследований
При этом используются те же 3 типа наследования: public, private и protected. Они могут накладывать свои особенности и Parent спецификаторы доступа.
#### public (открытое наследование)
```cpp
class Child: public Parent // открытое наследование
```
Если Child наследуют открыто, то Parent спецификаторы доступа действуют так же, как обычно (см. выше). 
| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | public |
| private | недоступен |
| protected | protected |     

Те, если Child унаследовал protected член через public наследование, то он так же может передать его следующему классу-наследнику (в цепочке наследования) как protected.

#### private (закрытое наследование)
При закрытом наследовании все члены родительского класса наследуются как закрытые. Это означает, что члены private остаются недоступными, а члены protected и public становятся private в дочернем классе (те, Child имеет к ним доступ, но нет доступа извне через экземпляры Child). 

| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | private |
| private | недоступен |
| protected | private |

#### protected (ащищённое наследование)
С защищённым наследованием, члены public и protected становятся protected, а члены private остаются недоступными.
| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | protected |
| private | недоступен |
| protected | protected |

#### Тип наследования по дефолту (без явного указания)
Для структур дефолтный тип (без явного указания) наследования - `public`. Для классов дефолтный тип - `private`.
```cpp
class C : B 	// B private by default
{ / ... / }; 
struct S : B 	// B public by default
{ / ... / }; 
```

#### Пример цепочки
```cpp
class Parent
{
public:
	int m_public;
private:
	int m_private;
protected:
	int m_protected;
};

class D2 : private Parent  // закрытое наследование
{
	// Закрытое наследование означает, что:
	// члены m_public и m_protected становятся private в дочернем классе;
	// члены m_private недоступен для дочернего класса.
public:
	int m_public2;
private:
	int m_private2;
protected:
	int m_protected2;
};

class D3 : public D2
{
	// Открытое наследование от D2 означает, что:
	/* Члены из D2: */
    // m_public2 остается public в D3 классе;
    // m_private2 остается private в D3 классе;
    // m_protected2 остается protected в D3 классе;
    
    /* Члены из Parent: */
	// m_public, m_protected и m_private - недоступны в D3 
public:
	int m_public3;
private:
	int m_private3;
protected:
	int m_protected3;
};
```

## Переопределение методов родительского класса 
При вызове метода через объект дочернего класса, компилятор сначала смотрит, существует ли этот метод в дочернем классе. Если нет, то он начинает продвигаться по цепочке наследования вверх и проверяет, был ли этот метод определён в любом из родительских классов. Использовать компилятор будет первое найденное определение.     

Чтобы переопределить родительский метод в Child классе, надо просто определить его как обычный метод, будто родительского метода и не было:
```cpp
class Parent
{
public:
    {
    }
 
    void identify() { std::cout << "I am a Parent!\n"; }
};

class Child : public Parent
{
public:
    Child()
    {
    }
    // Вот наш изменяемый метод родительского класса. Просто определяем его будто и не видели его никогда
    void identify() { std::cout << "I am a Child!\n"; }
};
```
- Когда мы переопределяем родительский метод в дочернем классе, то *дочерний метод не наследует спецификатор доступа родительского метода с тем же именем*. Используется тот спецификатор доступа, который указан в дочернем классе. Таким образом, метод, определённый как private в родительском классе, может быть переопределён как public в дочернем классе, или наоборот!
- Чтобы "расширить" родительский метод (те не переписывать его заново, а просто добавить что-то), можно просто внутри Child метода вызвать родительский метод:
	```cpp
	void identify()
	{
        	Parent::identify(); // сначала выполняется вызов Parent::identify() 
        	std::cout << "I am a Child!\n"; // затем уже вывод этого текста
	}
	```
- Если мы переопределяем ф-цию чтобы она принимала другой тп данных, но все же хотим, чтобы можно было зываеть ее и со сатрыи типом данных, то нужно включить протопип родительского метода. Наример,
	```cpp
	struct File {
		void write( char const * s);
	...
	};
	struct FormattedFile : File {
		void write(int i);
		void write( double d);
		...
	};

	int main()
	{
		FormattedFile f;
		f.write(4);		//ОК вызовет write(int i);
		f.write("Hello");	//НЕ ОК. Ф-ция write была переопределена и теперь у нее нет сигнатуры write(char *s);
	}
	```
	Можно это поправить дополнив прототипом нужной сигнатуры (`using File::write;`):
	```cpp
	struct FormattedFile : File {
		void write(int i);
		void write( double d);
		using File::write;
		...
	};
	```

### Изменение спецификатора доступа при переопределении метода (и сокрытие метода)
C++ предоставляет возможность изменить спецификатор доступа родительского члена в дочернем классе помощью using declaration. Например, можено сменить protected в родительском на public в Child (в примере, printValue()). **Сокрытие** - если мы хотим скрыть доступ какому-то открытому методу, то можно переопределить его доступ в ptivate (в примере, doSmth()). Пример,
```cpp
class Parent
{
private:
    int m_value;
 
public:
    Parent(int value)
        : m_value(value)
    {
    }
 
protected:
    void printValue() { std::cout << m_value; }
    void doSmth() {std::cout << "Ain't doing anything;}
};

class Child: public Parent
{
public:
    Child(int value)
        : Parent(value)
    {
    }
    
    // Parent::printValue является protected, поэтому доступ к нему не является открытым для всех объектов
    // Но мы можем это исправить с помощью using declaration
    using Parent::printValue; // обратите внимание, нет никаких скобок

private:
    using Parent::doSmth; // скрыли метод doSmth
};
```
**Сокрытие** - если мы хотим скрыть доступ какому-то открытому методу, то можно переопределить его доступ в ptivate.

## Множественное наследование
Множественное наследование позволяет одному дочернему классу иметь несколько родителей. Предположим, что мы хотим написать программу для отслеживания работы учителей. Учитель — это Human. Тем не менее, он также является Сотрудником (Employee). Реализуется как и обычная, но через запятую (для каждого указываем тип наследования):
```cpp
class Teacher: public Human, public Employee
{//опустим тело}
```
На самом деле, надо избегать этот случай тк может могут возникнуть множество проблем. Например, проблема конфликта имен у родителських методов. Если у родителей совпали имена методов, а у Child его нет, то возникнет ошибка: компилятор не будет знать какому из родителей отдать предпочтение: он равны в иерархии наследования. 

### Diamond of doom
<img src="https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/Diamond_inheritance.png" alt="Diamond_of_doom" width="200"/>
Это проблема возникает, когда два родителя (B и C) наследуют от одного про родителя (D). И в итоге они все встречаются в Child классе (A), те он наследует прородителя дважды. 
