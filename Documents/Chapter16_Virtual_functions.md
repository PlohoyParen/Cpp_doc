# Chapter16: Virtual functions
**Виртуальная функция** — это особый тип функции, которая, при её вызове, вызывает «наиболее» дочерний метод, который существует между родительским и дочерними классами. Для этого перед переопердяемой ф-цией ставится ключевое слово `virtual`.
## Полиморфизм (и постановка задачи)
**Полиморфизм** -  возможность объектов с одинаковой спецификацией иметь различную реализацию: "Один интерфейс, множество реализаций". Виртуальные ф-ции - это ключевой аспект реализации полиморфных объектов.    
Например, у нас есть класс Animal, который мы хотим использовать как основу для более специфических классов, например, Cat, Dog etc., 
```cpp
class Animal
{
protected:
    std::string m_name;

    /* Мы делаем этот конструктор protected так как не хотим,  чтобы пользователи создавали 
    объекты класса Animal напрямую, но хотим, чтобы у дочерних классов доступ был открыт */
    Animal(std::string name)
        : m_name(name)
    {
    }
public:
    std::string getName() { return m_name; }
    const char* speak() { return "???"; }
};
```
Теперь создадим дочерние классы на его основе, 
```cpp
class Cat: public Animal
{
public:
    Cat(std::string name)
        : Animal(name)
    {
    }
 
    const char* speak() { return "Meow"; } //переопределили ф-цию speak для класса Cat
};
 
class Dog: public Animal
{
public:
    Dog(std::string name)
        : Animal(name)
    {
    }
 
    const char* speak() { return "Woof"; }  //переопределили ф-цию speak для класса Dog
};
```
### Пример 1
Теперь, если мы захотим создать универсальный интерфейс работы с классами Cat и Dog, то у нас возникнет проблема. Например, если я хочу создать независимую ф-цию, вызвающую `speak()` для обоих классов, то мне придется сделать 2 перегрузки принимаюшие `Cat& cat` и `Dog& dog`. Есть решение по-лучше: я могу взять их общую точку отсчета - родительский класс Animal :`Animal& animal`,
```cpp
/*** Вместо этого ***/
void report(Cat &cat)
{
    std::cout << cat.getName() << " says " << cat.speak() << '\n';
}
 
void report(Dog &dog)
{
    std::cout << dog.getName() << " says " << dog.speak() << '\n';
}

/*** Сделать это ***/
void report(Animal &rAnimal)
{
    std::cout << rAnimal.getName() << " says " << rAnimal.speak() << '\n';
}
```
Проблема в том, что при вызове `report(cat)` будет сделан "срез" родительской части (тк ссылка идеть только на родительскую часть), а значит перегрузка ф-ции `speak()` не будет учтена и бедт вызвана ее родительская форма.     
Тут на помощь приходят виртуальные ф-ции. В этом случаии, если мы сделаем `virtual const char* speak() { return "???"; }` в родительском классе, то компилятор, увидя, что ф-ция виртуальная, будет искать наиболее дочернюю перегрузку этой ф-ции (те ф-ции дочерних классов Cat и Dog).     
### Пример 2 
Хотим создать массив, куда соберем разных животных. Тк Cat и Dog - это разные массивы, то с этим будет проблема. Можно аналогичено создать массив класса Animal, а методы, которые мы хотим использовать для их элементов сделать вирутальными,
```cpp
Cat matros("Matros"), ivan("Ivan"), martun("Martun");
Dog barsik("Barsik"), tolik("Tolik"), tyzik("Tyzik");
 
// Создаём массив указателей на наши объекты Cat и Dog
Animal *animals[] = { &matros, &barsik, &ivan, &tolik, &martun, &tyzik};
for (int iii=0; iii < 6; ++iii)
    std::cout << animals[iii]->getName() << " says " << animals[iii]->speak() << '\n'
```

## Особенности использования виртуальных ф-ций
### Пример цепочки наследования 
```cpp
class A
{
public:
    virtual const char* getName() { return "A"; }
};
 
class B: public A
{
public:
    virtual const char* getName() { return "B"; }
};
 
class C: public B
{
public:
    virtual const char* getName() { return "C"; }
};
 
class D: public C
{
public:
    virtual const char* getName() { return "D"; }
};
 
int main()
{
    C c;
    B &rParent = c;
    std::cout << "rParent is a " << rParent.getName() << '\n';
 
    return 0;
}

/***** Будет выведенно *****
rParent is a B
***************************/
```
В данном примере демонстрируется как работает "срез" и вирутуальная ф-ция. Мы сделали срез по классу B из его дочернего класса C. Далее мы вызываем ф-цию getName(). Компилятор обнаруживает, что это virtual ф-ция и начинает идти вверх по дочерним классам, пока не найдет наиболее дочернюю для *данного случая* перегрузку. В данном случаи это перегрузка для дочернего класса C. Он не пойдет далее в класса D, тк он лежит за рамками данного случая. 

### Корректная перегрузка виртульных ф-ций
Перегруженные вресии виртуальных ф-ций должны полностью совпадать по: 
1. Сигнатуре (имя, типы параметров и является ли метод константным),
2. Типу возвращаемого значения.     
Считай быть идентичными по сигнатуре.

#### Ковариантный тип возврата
Исключением являются ф-ции с **Ковариантным типом возврата** - это когда метод некоторого класса возвращает указатель на самого себя. В этом случаии позволительно иметь различные типы возвращаемого значения. Например,
```cpp
class Parent{
public:
    virtual Parent* getThis() { std::cout << "called Parent::getThis()\n"; return this; }
}
class Child: public Parent
{
public:
    virtual Child* getThis() { std::cout << "called Child::getThis()\n";  return this; }
}
```
### Порядок указания virtual
Не обязательно указывать `virtual` рядом скаждой перегрузкой ф-ции. Достаточно указать это у родителя (у класса, по которому пойдет срез). Например, в данном случаи все следующие 3 варанта будут работать:
1. Случаий 1, это когда `virtual` указывается для всех ф-ций, задуманных как virtual. Это самый лучший способ, тк улучшает читаемость кода. 
2. ```cpp
    // 2. Случай virtual написано у самого "глубокого" родятеля
    class A
    {
    public:
        virtual const char* getName() { return "A"; }
    };
    class B: public A
    {
    public:
        const char* getName() { return "B"; }
    };
    class C: public B
    {
    public:
        const char* getName() { return "C"; }
    };

     int main()
     {
        C c;
        B &rParent = c;
        std::cout << "rParent is a " << rParent.getName() << '\n';

        return 0;
     }
     ```
3. ```cpp
    // 3. Случай virtual написано у родятеля по которому идет срез
    class A
    {
    public:
        const char* getName() { return "A"; }
    };
    class B: public A
    {
    public:
        virtual const char* getName() { return "B"; }
    };
    class C: public B
    {
    public:
        const char* getName() { return "C"; }
    };

     int main()
     {
        C c;
        B &rParent = c;
        std::cout << "rParent is a " << rParent.getName() << '\n';

        return 0;
     }
     ```
     Тут нужно отметить, что в данном случаии виртуальные ф-ции начинаются с класса B. Поэтому, если бы срез был `A &rParent = c;` то перегрузка бы не срабоата, тк для класса A ф-ция getName() не является виртуальной.     

### Когда НЕ использовать virtual
1. Виртуальные ф-ции работают медленнее, чем обычные. Более того, для каждого экземпляра класса с виртуальной ф-цией компилятор создает дополнительный указатель для своей внутренней работы. Таким образом, следуют использовать virtual только в случаии явной реализации полиморфизма кода. 
2. Не следует использвать virtual для ф-ций вызываемых в конструкторах и деструкторах. В конструкторах самым дочерний класс создается в последнюю очередь, в деструкторе самый дочерний класс будет уничтожен первым. Все это вызывает некоррестное повидение.

## Final and override
### Override
Это модификатор (те слово значение, которого зависит от контекста. Хотя у override есть только 1 корректный контекст), говорящий компилятору, что данная ф-ция задумывалась как виртуальная. Поэтому, если по какой-то причине не происходит ее перегрузка (например, неправильно написана сигнатура), то компилятор выдаст ошибку. Записывать ее следуюет так,
```cpp
class A
{
public:
	virtual const char* getName1(int x) { return "A"; }
	virtual const char* getName2(int x) { return "A"; }
	virtual const char* getName3(int x) { return "A"; }
};
 
class B : public A
{
public:
	virtual const char* getName1(short int x) override { return "B"; } // ошибка компиляции, метод не является переопределением
	virtual const char* getName2(int x) const override { return "B"; } // ошибка компиляции, метод не является переопределением
	virtual const char* getName3(int x) override { return "B"; } // всё хорошо, метод является переопределением A::getName3(int)
 
};
```
Это полезная штука, которую следует всегда использовать как проверку выполнения виртуальности ф-ции.
### Final 
#### Для виртуальной ф-ции
Это модификатор запрещающий дальнейшее наследования (для классов) и переопределение (для виртуальных ф-ций). Например,
```cpp
class A
{
public:
	virtual const char* getName() { return "A"; }
};
 
class B : public A
{
public:
	// Заметили final в конце? Это означает, что метод переопределить уже нельзя
	virtual const char* getName() override final { return "B"; } // всё хорошо, переопределение A::getName()
};
```
Это значит, что, если некоторый класса C, являющейся наследником для B, попробует переопределить ф-цию getName(), то компилятор выдаст ошибку. Дальнейшее переопределение запрещено.
#### Для класса 
```cpp
class A
{
public:
	virtual const char* getName() { return "A"; }
};
 
class B final : public A // обратите внимание на модификатор final здесь
{
public:
	virtual const char* getName() override { return "B"; }
};
 
class C : public B // ошибка компиляции: нельзя наследовать класс final
{
public:
	virtual const char* getName() override { return "C"; }
};
```
Тут класс C не может стать наследником класса B, тк у него стоит модификатор final.

## Виртуальный деструктор 
Если программа предсматривает *полиморфное* повидение некоторого класса, то его деструктор должен быть виртулальным. Под полиморфным повидением подразумевается вероятность использования "срезов", те указателей Parent классов для указания на их дочерние подклассы. Суть виртуального деструктора аналогична виртуальным ф-циям: вызов самого дочернего деструктора. Пример, где это необходимо,
```cpp
class Parent
{
public:
    ~Parent() // примечание: Деструктор не виртуальный
    {
        std::cout << "Parent: я тут вообще ничего не делаю" << std::endl;
    }
};
 
class Child: public Parent
{
private:
    int* m_array;
 
public:
    Child(int length)
    {
        m_array = new int[length];
    }
 
    ~Child() // примечание: Деструктор не виртуальный
    {
        std::cout << "Child: а я чистю память" << std::endl;
        delete[] m_array;
    }
};
 
int main()
{
    Parent *parent =  new Child(7);
    delete parent; // вызывается деструтруктор класса Parent, который не высвобождает выделенную память.
 	
    return 0;
}
```
В этом случаи у нас произойдет утечка памяти, тк был вызван Parent деструктор, который не удаляет Child часть класса (он о ней даже не знает). Ситуацию спасет `virtual`, 
```cpp
virtual ~Parent() // примечание: Деструктор виртуальный
{
	std::cout << "Calling ~Parent()" << std::endl;
}
```
Теперь будет вызван самый дочерний деструктор. Можно спать спокойно!

## Виртуальные табилцы (virtual tables)
Когда програмист объявляет виртуальную ф-цию, компилятор автоматически добавляет в каждый класс следующие компоненты.
1. Виртуальная таблица (virtual method table (VMT))
2. Скрытый указатель на вирутуальную таблицу (`*__vptr`) (по 1 на каждый экземпляр)
     
### 1. Виртуальные таблицы (VMT)
Чтобы класс всегда знал какие из виртуальных ф-ций наиболее дочернии используется виртуальная таблица. Это статический массив, каждый элемент которого это указатель на наиболее дочений метод доступный данному классу. На каждый класс есть только 1 виртуальная таблица, которая хранится в statiс памяти, и к ней имеют доступ все экземпляры данного класса. Это также значит, что таблица не увеличивает размер объекта данного класса.     
Другой важный момент заключается в том, что каждый класс имеет свою таблицу. Те, если у нас есть Parent класс и два наследника, то у каждого будет своя таблица (те всего 3 таблицы). Например, у нас есть 2 класса: B (parent) и C (child),
```cpp
class B
{
public:
  virtual void bar();
  virtual void qux();
};

void B::bar() { std::cout << "This is B's implementation of bar" << std::endl;}
void B::qux() { std::cout << "This is B's implementation of qux" << std::endl;}

class C : public B
{
public:
  void bar() override;
};
void C::bar() { std::cout << "This is C's implementation of bar" << std::endl;}

int main()
{
	B* b = new C(); // сделали "срез" класса C по его родительской части (класс B)
	b->bar(); // ф-ция bar - виртуальная и имеет перегрузку в классе C
}
```
В этом случаии таблицы для классов B и C будут выглядеть следующим образом,
<img src = "https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/vpointer.png" alt = "vpointer" width = "200" />
