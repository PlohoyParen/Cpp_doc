# Chapter 17: Шаблоны
## Шаблоны ф-ций 
Суть шаблона заключается в том, что компилятор сам подставляет тип данных в ф-цию на основе передаваемого типа данных. Например, 
```cpp
template <typename T> // объявление параметра шаблона функции
T max(T a, T b)
{
    return (a > b) ? a : b;
}
```
- При создании шаблона необходимо сделать объявление шаблона (`template <typename T>`). Вместо ключевого слова `typename` можно использовать `class` (`template <class T>`), однако лучше его оставить для обозначения шаблонов классов. Если речь идет об объявлении имени параметра шаблона, то разницы нет. Однако, в случаии, объявления переменной зависимой от шаблона необходимо использовать `typename`. Например,
  ```cpp
  template<typename T>              //(тут неважно)
  struct X : B<T>                   // "B<T>" is dependent on T
  {
      typename T::A* pa;            // "T::A" is dependent on T (тут важно)
                                    // (see below for the meaning of this use of "typename")
      void f(B<T>* pb) {
          static int i = B<T>::i;   // "B<T>::i" is dependent on T
          pb->j++;                  // "pb->j" is dependent on T
      }
  };
  ```
- Если объявляются сразу несколько параметров шаблона, то они пишутся через запятую: `template <typename T1, typename T2>`.
- Так как шаблоны работают не только для базовых типов данных, то **компилятор так же может вставлять и пользовательские классы**. Поэтому, имеет смысл писать шаблоны ф-ций с передачей и возвращением данных через const ссылки (а не по значению, как в примере в начале):
  ```cpp
  template <typename T>
  const T& max(const T& a, const T& b)
  {
      return (a > b) ? a : b;
  }
  ```
  При этом, следует помнить, что компилятор не делает ничего умного, он только вставляет тип данных вместо параметра шаблона. Поэтому, если в теле ф-ции делаются неизвестные компилятору действия, то будет ошибка. Например, в примере выше пользовательский класс должен иметь перегрузку оператора сравнения, иначе будет обшибка. 

### Как компилятор реализует шаблоны ф-ций
Когда компилятор встречает вызов обычной ф-ции, он просто вставляет адрес реализации этой ф-ции на месте его вызова. В случаии шаблона ф-ции, компилятор вставляет всю реализацию ф-ции целиком (подобно опертору inline) на месте вызова заменяя переменные шаблона на подходящие типы данных. Таким образом, если шаблон ф-ции был вызван несколько раз с разными типами данных, то и реализация ф-ции будет вставлена несколько раз. Каждая такая вставка называется **экземпляром шаблонов функций**. Например:
```cpp
 
template <typename T>
const T& max(const T& a, const T& b)
{
    return (a > b) ? a : b;
}
 
int main()
{
    int i = max(4, 8);              /* на самом деле тут стоит 
                                    const int& max(const int& a, const int& b)
                                    {
                                        return (a > b) ? a : b;
                                    }
                                    */
    std::cout << i << '\n';
 
    double d = max(7.56, 21.434);   /* на самом деле тут стоит 
                                    const double& max(const double& a, const double& b)
                                    {
                                        return (a > b) ? a : b;
                                    }
                                    */
    std::cout << d << '\n';
        
    char ch = max('b', '9');        /* на самом деле тут стоит 
                                    const ch& max(const ch& a, const ch& b)
                                    {
                                        return (a > b) ? a : b;
                                    }
                                    */
    std::cout << ch << '\n';
        
    return 0;
}
```
## Шаблоны классов
Синтаксис для шаблонов класса такой же как и для шаблонов ф-ций. Добавляется `template<class T>` и далее T используется там, где нужны вариации типа данных. Шаблоны классов работают точно так же, как и шаблоны функций: компилятор копирует шаблон класса, заменяя типы параметров шаблона класса на фактические (передаваемые) типы данных, а затем компилирует эту копию. Если у вас есть шаблон класса, но вы его не используете, то компилятор не будет его даже компилировать. Например, ниже представлен шаблон класса `Array<T>`. 
```cpp
/*** внутри файла Array.h (ниже будет почему это важно) ***/
template <class T> // это шаблон класса с T вместо фактического (передаваемого) типа данных
class Array
{
private:
    int m_length;
    T *m_data;                      //указатель на T 
public:
    Array(int length)
    {
        m_data = new T[length];     //динамически выделили память под массив типа T
        m_length = length;
    }
    ~Array()
    {
        delete[] m_data;
    } 
 
    T& operator[](int index)        //возврат ссылки на тип данных T
    {
        assert(index >= 0 && index < m_length);
        return m_data[index];
    }
 
    // Длина массива всегда является целочисленным значением, она не зависит от типа элементов массива
    int getLength(); // определяем метод и шаблон метода getLength() ниже
};
 
template <typename T> // метод, определенный вне тела класса, нуждается в собственном определении шаблона метода
int Array<T>::getLength() { return m_length; } // обратите внимание, имя класса - Array<T>, а не просто Array
```
- Это шаблон класса `Array<T>`, а не `Array`, хотя в названии класса не стоит `<T>`. При создании экземпляра всегда надо указывать тип данных в скобках (так, для примера выше `Array<int> intArray(10)`).
- Определение ф-ции getLength() мы вынести за тело класса. В этом случаии необходимо: 1) вновь указать компилятору, что мы используем параметр шаблона T: `template <typename T> `; 2) добавить <T> в название класса (в зоне видисоти): `Array<T>::getLength()`.

### Заголовочные файлы
Обычно класс реализуется в 2 файлах: объявление в .h и реализация методов в .cpp. В C++ компилятор компилирует отдельно каждый .cpp файл, а встречая .h просто копирует его содержимоев в соответсующий .cpp; затем линкер все соединяет. Так получается, что в main.cpp компилятор создает единственное объявление некоторого класса, а при работе программы вызывает реализацию из другого .cpp. Тут возникает проблема: каждый раз, когда мы создаем шаблон, компилятор копирует *весь* код объявляемого класса из .h, на место вызова. На этапе компиляции у него нет доступа к другим .cpp, включая файл с реалицаций методов шаблона класса. Поэтому, с точки зрения компилятора реализаций методов (из .cpp) не существует. Есть 3 решения у этой проблемы:
1. Использовать 1 файл: .h и всю реализацию оставить там. Если класс небольшой, то это лучший выход: просто определить все внутри .h.
2. Использовать 2 файла: .h для объявления, и файл `.inl` (от inline) c реализаций. Нужно просто переименовать MyName.cpp в MyName.inl, а затем подключить MyName.inl из нижней части файла MyName.h.
3. Использовать 3 файла: .h для объявления нашего класса, .cpp c реализаций нашего класса и еще один .cpp, где мы соберем все вместе, включив все файлы шаблонов этого и других классов. Вот пример 3го файла (templates.cpp):
    ```cpp
    /***  templates.cpp ***/
    // Таким образом, мы гарантируем, что компилятор увидит полное определение шаблона класса Array
    #include "Array.h"
    #include "Array.cpp" // мы нарушаем правила хорошего тона программирования, но только в этом месте

    // Здесь вы #include другие файлы .h и .cpp с определениями шаблонов, которые вам нужны

    template class Array<int>; // явно создаем экземпляр шаблона класса Array<int>
    template class Array<double>; // явно создаем экземпляр шаблона класса Array<double>

    // Здесь вы явно создаете другие экземпляры шаблонов, которые вам нужны
    ```
    Часть `template class` заставит компилятора явно создать указанные экземпляры шаблона класса. В примере, приведенном выше, компилятор создаст Array<int> и Array<double> внутри `templates.cpp`. Поскольку templates.cpp находится внутри нашего проекта, то он скомпилируется и удачно свяжется с другими файлами (пройдет линкинг).
