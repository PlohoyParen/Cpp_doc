# Chapter 18: Iterators
**Iterator** - это специальный тип данных, который ведет себя подобно указателю, у который есть ряд расширенных возможностей. У каждого контейнера, входящего в STL обязательно есть возможность работы с итераторами. Более того, тип данных итератора зависит от конкретного контейнера. 
## Основы синтаксиса
Самым простым (и облажающий самыми широкими возможностями) является итератор работающий с непрерывнми контейнерами (где последовательные элементы лежат в памяти последовательно). Возьмем для примера `std::vector`. Его итератор имеет тип данных `std::vector<int>::iterator`.      

<img src = "https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/iterator.png" alt = "iterator" width = 500 >


```cpp
std::vector<int> v = {1,2,3,4,5,6};
//можно целиком писать тип данных итератора
std::vector<int>::iterator beg = v.begin(); //указывает на 1
//но удобнее использовать auto 
auto end = v.end();                         //указывает на ячейку памяти следующую за 6
  
//Range-based for - реализованы на основе итераторов
for (auto i = v.begin() + 1, e = v.end() - 2; i !=e; ++i)
{
  std::count << *i << " ";                  // for пробегающий [2, 3, 4, 5]
}
```

- У каждого контейнера из STL есть 2 метода: `begin()` (возвращает итератор указывющий на 1й элемент контейнера) и `end()` (возвращает итератор указывющий на ячейку памяти следующую за последним элементом контейнера). Так итератор обычно работают в диапозоне: **[begin, end)**.    
- Для итераторов работает арифметика указателей. Те инкремент `++i` передвинит итератор на следующий элемент, а `--i` на предыдущий. Важно отметить, что зачастую `++i` работает быстрее, чем `i--`, поэтому работая с итераторами **следуюет использовать ++i**. Если контейнер последовательный, то можно делать шаг в n элеметнов: `i+n` или `i-n`, где n - это int число. Разница итераторов работает аналогично указателям: `v.end() - v.begin()` - вернет размер контейнера.
- Разименование происхоидт аналогично указателям: `*i` возвращает ссылку на элемент. Например, `*(v.begin()+k)` - возвращает ссылку на k-й элемент контейнера v. Для итераторов `i->x` работает так же как и для указателей - это значит `(*i).x`.


## Iterator invalidation 
