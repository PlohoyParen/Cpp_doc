# Chapter 18: Iterators
**Iterator** - это специальный тип данных, который ведет себя подобно указателю, у который есть ряд расширенных возможностей. У каждого контейнера, входящего в STL обязательно есть возможность работы с итераторами. Более того, тип данных итератора зависит от конкретного контейнера. 
## Основы синтаксиса
Основной синтаксис и операции аналогичны операциям с указателями.     

Самым простым (и облажающий самыми широкими возможностями) является итератор работающий с непрерывнми контейнерами (где последовательные элементы лежат в памяти последовательно). Возьмем для примера `std::vector`. Его итератор имеет тип данных `std::vector<int>::iterator`.      

<img src = "https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/iterator.png" alt = "iterator" width = 500 >


```cpp
std::vector<int> v = {0,1,2,3,4,5,6};
//можно целиком писать тип данных итератора
std::vector<int>::iterator beg = v.begin(); //указывает на 1
//но удобнее использовать auto 
auto end = v.end();                         //указывает на ячейку памяти следующую за 6
  
//Range-based for - реализованы на основе итераторов
for (auto i = v.begin() + 1, e = v.end() - 2; i !=e; ++i)
{
  std::count << *i << " ";                  // for пробегающий {1, 2, 3, 4, 5}
}
```

- У каждого контейнера из STL есть 2 метода: `begin()` (возвращает итератор указывющий на 1й элемент контейнера) и `end()` (возвращает итератор указывющий на ячейку памяти следующую за последним элементом контейнера). Так итератор обычно работают в диапозоне: **[begin, end)**.    
- Для итераторов работает арифметика указателей. Те инкремент `++i` передвинит итератор на следующий элемент, а `--i` на предыдущий. Важно отметить, что зачастую `++i` работает быстрее, чем `i--`, поэтому работая с итераторами **следуюет использовать ++i**. Если контейнер последовательный, то можно делать шаг в n элеметнов: `i+n` или `i-n`, где n - это int число. Разница итераторов работает как у указателей: `v.end() - v.begin()` - вернет размер контейнера.
- Разименование происхоидт аналогично указателям: `*i` возвращает ссылку на элемент. Например, `*(v.begin()+k)` - возвращает ссылку на k-й элемент контейнера v. Для итераторов `i->x` работает так же как и для указателей - это значит `(*i).x`.


### Iterator invalidation 
Одно из главных отличий итераторов от указателей - это то, что компилятор проверяет корректность операций над итераторами. Если операция некорректна, то срабатывает Исключение. Что может пойти не так? Например:
- `*v.end()` - пытаемся разименовать итератор указывающий на следующий за контейнером элемент, те лежащий вне контейнера. Исключение! 
- `--v.begin()` - декрементрировали за пределы контейнера. Исключение! 
- ```cpp
  std::vector<int> v = {0,1,2,3,4,5,6,7};
  auto i_invalid = v.begin() + 4;         //указывает на элемент 4
  v.erase(v.begin() + 3, v.begin() + 6);  //стерили из vector элементы [3, 5], теперь v={0,1,2,6,7}
  std::cout << *i_invalid;                //пытаемся разименовать элемент 4
  ```
  Мы создали итератор на элемент 4 нашего вектора. Затем мы стерли элементы [3,5]. Теперь пытаемся разименовать итератор, но он теперь указывает на 7 (тк erase удаляет указанные элементы и сдвигает последующие). Итератор понимает, что это не то чего мы хочем и вызовет Исколючение! 

- ```cpp
  std::vector<int> v = {0,1,2,3,4,5,6,7};
  auto i_invalid = v.begin() + 4;         //указывает на элемент 4
  v.push_back(69);                        //пристраиваем  69 в конец вектора
  std::cout << *i_invalid;                //пытаемся разименовать элемент 4
  ```
  Мы создали итератор на элемент 4 нашего вектора. Затем мы добавляем число 69 в конец вектора. Если при этом не хватит capacity этого вектора (см подробнее в главе про [std::vector](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter12_std_data_types.md#vector-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2-%D0%BB%D1%8E%D0%B1%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0), то ему придется выделить новый участок памяти и скоприровать свое содержимое туда, освободив старую память. В этом случаии итератор будет указывать на старый участок памяти. И этого не хотим, поэтому он вызовет Исключение!
  
