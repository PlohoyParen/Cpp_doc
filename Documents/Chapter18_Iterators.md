# Chapter 18: Iterators
**Iterator** - это специальный тип данных, который ведет себя подобно указателю, у который есть ряд расширенных возможностей. Под капотом это и есть указатель, но к нем прикручено много крутых фишек. У каждого контейнера, входящего в STL обязательно есть возможность работы с итераторами. Тип данных итератора и его реализация зависит от конкретного контейнера.

## Основы синтаксиса
Основной синтаксис и операции аналогичны операциям с указателями.     

Самым простым (и облажающий самыми широкими возможностями) является итератор работающий с непрерывнми контейнерами (где последовательные элементы лежат в памяти последовательно). Возьмем для примера `std::vector`. Его итератор имеет тип данных `std::vector<int>::iterator`.      

<img src = "https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/images/iterator.png" alt = "iterator" width = 500 >


```cpp
std::vector<int> v = {0,1,2,3,4,5,6};
//можно целиком писать тип данных итератора
std::vector<int>::iterator beg = v.begin(); //указывает на 1
//но удобнее использовать auto 
auto end = v.end();                         //указывает на ячейку памяти следующую за 6
  
//Range-based for - реализованы на основе итераторов
for (auto i = v.begin() + 1, e = v.end() - 2; i !=e; ++i)
{
  std::count << *i << " ";                  // for пробегающий {1, 2, 3, 4, 5}
}
```

- У каждого контейнера из STL есть 2 метода: `begin()` (возвращает итератор указывющий на 1й элемент контейнера) и `end()` (возвращает итератор указывющий на ячейку памяти следующую за последним элементом контейнера). Так итератор обычно работают в диапозоне: **[begin, end)**.    
- Для итераторов работает арифметика указателей. Те инкремент `++i` передвинит итератор на следующий элемент, а `--i` на предыдущий. Важно отметить, что зачастую `++i` работает быстрее, чем `i--`, поэтому работая с итераторами **следуюет использовать ++i**. Если контейнер последовательный, то можно делать шаг в n элеметнов: `i+n` или `i-n`, где n - это int число. Разница итераторов работает как у указателей: `v.end() - v.begin()` - вернет размер контейнера.
- Разименование происхоидт аналогично указателям: `*i` возвращает ссылку на элемент. Например, `*(v.begin()+k)` - возвращает ссылку на k-й элемент контейнера v. Для итераторов `i->x` работает так же как и для указателей - это значит `(*i).x`.

### Iterator invalidation 
Одно из главных отличий итераторов от указателей - это то, что компилятор проверяет корректность операций над итераторами. Если операция некорректна, то срабатывает Исключение. Что может пойти не так? Например:
- `*v.end()` - пытаемся разименовать итератор указывающий на следующий за контейнером элемент, те лежащий вне контейнера. Исключение! 
- `--v.begin()` - декрементрировали за пределы контейнера. Исключение! 
- ```cpp
  std::vector<int> v = {0,1,2,3,4,5,6,7};
  auto i_invalid = v.begin() + 4;         //указывает на элемент 4
  v.erase(v.begin() + 3, v.begin() + 6);  //стерили из vector элементы [3, 5], теперь v={0,1,2,6,7}
  std::cout << *i_invalid;                //пытаемся разименовать элемент 4
  ```
  Мы создали итератор на элемент 4 нашего вектора. Затем мы стерли элементы [3,5]. Теперь пытаемся разименовать итератор, но он теперь указывает на 7 (тк erase удаляет указанные элементы и сдвигает последующие). Итератор понимает, что это не то чего мы хочем и вызовет Исколючение! 

- ```cpp
  std::vector<int> v = {0,1,2,3,4,5,6,7};
  auto i_invalid = v.begin() + 4;         //указывает на элемент 4
  v.push_back(69);                        //пристраиваем  69 в конец вектора
  std::cout << *i_invalid;                //пытаемся разименовать элемент 4
  ```
  Мы создали итератор на элемент 4 нашего вектора. Затем мы добавляем число 69 в конец вектора. Если при этом не хватит capacity этого вектора (см подробнее в главе про [std::vector](https://github.com/PlohoyParen/Cpp_doc/blob/master/Documents/Chapter12_std_data_types.md#vector-%D0%BE%D0%B4%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%BD%D1%8B%D0%B9-%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2-%D0%BB%D1%8E%D0%B1%D0%BE%D0%B3%D0%BE-%D1%82%D0%B8%D0%BF%D0%B0), то ему придется выделить новый участок памяти и скоприровать свое содержимое туда, освободив старую память. В этом случаии итератор будет указывать на старый участок памяти. И этого не хотим, поэтому он вызовет Исключение!            
 
И куча других случаев. На самом деле, при работе с STL контейнерами многие методы могут invalidate (сломать и вызвать Исключение) итераторы, поэтому нужно смотреть докуметнацию к используемым методам (как это происходит с erase() и push_back() в примерах выше).      

-------

При этом, некоторые методы не только колечат итераторы, но и лечат их тоже. Например, следующий код с erase() вызовет Исключение:
```cpp
std::vector<int> v = {1,2,3,4,5};
for (auto i = v.begin(), e = v.end(); i != e; ++i)
{
  if(*i % 2 == 0)     //удаляем четные элементы
  {
    v.erase(i); 
  } 
}
```
Мы инициализуем итератор i в начале, а потом инкрементируем его в цикле. Тк при работе erase() сместит все элементы на место удаленного (те теперь v = {1,3,4,5}), то итератор будет указывать на неправильный элемент (в новом цикле попадет на 4, перескочив 3), что вызовет Исколючение. К счастью, erase() умнее, чем кажется, и когда он смещает все элементы на место только что удаленных, он возвращает итератор на первый из смещенных элеметнов (те на элемент 3). Таким образом, следующий код будет делать именно то, что мы хотим
```cpp
std::vector<int> v = {1,2,3,4,5};
for (auto i = v.begin(), e = v.end(); i != e;)
{
  if(*i % 2 == 0)     //удаляем четные элементы
  {
    i = v.erase(i);   //удаляем и возвращем итератор на первый из сдвинутых элементов
  }      
  else
  {
    ++i;
  }
}
```

## Инкриментирование в итераторах
Пожалуй, главным преимушеством итератора над обычными указателями (и индексированием) является то, что **арифметика итераторов - умная арифметрика!**. Чтобы понять, что это значит сравним два вида контейнеров: vector и forward_list (это такой связанный список, где переместиться можно только 1 элемент вперед, тк только данный элемент знает адрес последующего).
- **vector** - нет особых проблем при перемещении между элементами непрерывного контейнера (например, array, vector или string), и можно использовать обычные указатели и индексирование. Например, арифметика для векторов будет рабоать одинаково для как для указателей, так и для итераторов: 
  ```cpp
  std::vector<int> v1 = { 1,2,3,4,5,6 };
  auto* v = &v1[0];
  std::cout << v[4] << ' ' << *(v + 3); // Все эти действия разрешены и будут работать как и ожидается.
  std::cout << *(++v);                  // Хотя и выглядит немного насильственно
  
  auto i = v.begin();   //создали итератор
  std::cout << *(i+4) << *(i+5);        //выведет то же самое. Индексирование для итераторов не работает
  std::cout << *(++i);
  ```
- **forward_list** - мы можем переместиться только на 1 элемент за раз, а также последовательные элементы списка лежат в памяти непоследовательно. Поэтому арифметрика указателей тут запрещена (и не имеет особого смысла, тк элементы не последовательны в памяти). В то же время, арифметрика итераторов работает (однако разрешены только `++i` и `i++`:  
  ```cpp
  std::forward_list<int> li {1,2,3,4,5,6};
  auto i = li.begin();
  std::cout << *(i) << std::endl;
  std::cout << *(++i); 
  ```

## Итераторы бывают разные
В зависимости от контейнера итератор может обладать разными возможностями. Типы итераторов и их особенности можно найти в [документации](http://www.cplusplus.com/reference/iterator/). В общем случаии, любой итератор может/имеет:
1. Конструктор копирования и оператор присваивания. Он также имеет деструктор (так что он сам за собой приберет).
2. Оператор инкремента `++i` и `i++` (но не обязательно имее декримент).
3. Оператор разименовывания (у некоторых он для rvalue, а у некоторых lvalue)      

Остальные возможности зависят от типа итератора.

## Почему вся STL построена на итераторах?
Использование итераторв позволяет писать универсальный код для самого разного типа контейнеров. Пусть мы хотим написать ф-цию, которая выводит элементы любого контейнера из STL. Мы не можем использовать указатели или индексирование, тк это не сработает для непоследовательных контейнеров (например, forward_list). Выход - итераторы:
```cpp
template<typename Iter>             // тип итератора зависит от контейнера
void print(Iter begin, Iter end)
{
    for (; begin != end; ++begin)
    {
        std::cout << *begin << " "; //итераторы прекрасно работают с ф-циями STL, включая потоки
    }
}

int main()
{
    std::vector<int> v{ 1,2,3,4,5,6 };
    std::forward_list<int> li{ 1,2,3,4,5,6 };
    std::string str = "asdgbvc";


    print(v.begin() + 1, v.end() - 1);  //можем и срез отправить
    print(li.begin(), li.end());
    print(str.begin(), str.end());
    return 0;
} 
```
По этой причине большиство ф-ций входящих в STL работают на итераторах. Библиотека <algorithm> вообще целиком на них работает.

