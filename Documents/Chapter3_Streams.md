# Chapter 3 Streams 

## std::cin
`cin >> ..` - поток ввода. Из буфера в переменую сохраняется только соответсвующая переменной часть (т.е. для int - число до пробела, для char - один символ и тд). Остальная часть пользовательского ввода останется во входном буфере, который использует cin и будет доступна для использования последующим вызовам cin (`cin << a << b << c;` a, b, c - три раза вызов cin).

### Обработка некорректного ввода
При некорректном вводе (переполнение или неправельный тип принимающией переменной), надо очистить буфер:
```cpp
// при некорректном вводе, отчистит буфер
if (std::cin.fail()) 		 // если предыдущее извлечение не выполнилось или произошло переполнение,
{
    std::cin.clear(); 		 // то возвращаем cin в 'обычный' режим работы
    std::cin.ignore(32767,'\n'); // и удаляем значения предыдущего ввода из входного буфера
}
else 
    return a;			 // В случаи, что проблем нет возращаем введенные данные
```
Можно сделать `while(true){}`, где принимать `std::cin >> a;`, а затем проводить тест используя кусок кода выше. Тогда, если все ОК то данные пройдут, если не ОК, то буфер отчистится и пользователь введет данные еще раз.

### getline(cin, str)
The getline() function extracts characters from the input stream and appends it to the string object until the delimiting character is encountered. While doing so the previously stored value in the string object str will be replaced by the input string if any.
```cpp
string name; 
cout << "Please enter your name: \n"; 
getline(cin, name); 
```

### get(char)
Метод `cin.get()` принимает значения по-символьно.  `char c; cin.get(c);` - сохраняет полученный символ в переменную с. Если ввод закончен (и соотв. сin.get ничего не получает), то она возвращает `false`(поэтому ее удобно использовать в while и if). Также
`cin.get()` (без указания символьной переменной) - принимает любое значение и никуда его не сохраянет (т.к. мы не передали ей переменную для этого), обычно так ее ставят в конце программы, чтобы терминал не закрылся сразу после завершения основного цикла программы. 
```cpp
// снипет посимвольного ввода 
char c = '\0';  // инициализируем "пустым" символом (можно и ничем не инициализировать
while (cin.get(c))
{ // на каждой итерации считываем один символ в переменную c
    /* здесь можно пользоваться значением прочитанным в переменную c */
    if (c != 'a')
        cout << c; // выводим символ, если он не равен 'a'
}
```


## std::cout
`cout << endl;` - после вывода переведет на новую строку  

**Precision**
`std::setprecision(number);` 	
```cpp
#include <iostream>
#include <iomanip>					 // для std::setprecision()
std::cout << std::setprecision(16); 			 // задаём точность в 16 цифр
float f = 3.33333333333333333333333333333333333333f;     // выдаст 3.333333253860474
std::cout << f << std::endl;
double d = 3.3333333333333333333333333333333333333;	// выдаст 3.333333333333333
std::cout << d << std::endl;
```
Точность по типам данных: 
-float: от 6 до 9 цифр (в основном 7);
-double: от 15 до 18 цифр (в основном 16);
-long double: 15, 18 или 33 цифры;      
(Точность типа данных - *лимитирующий фактор*: округляется все по типу данных, а не точности вывода. Так, если float имеет 7 цифр, то cout до 9 цифр выведет первые 7 правильно, а потом фигню)  

**bool**
`std::cout << std::boolalpha; // выводит логические значения как "true" или "false"`

**std::endl**
Конец и перевод строки. Прежде чем закончить строку проверяет выведены ли все данные из буфера вывода, в отличии от `\n`, который просто переводит строку (не проверяе ничего).

### std::cout перобразование
При передаче указателя *не* типа `char`, в результате выводится просто содержимое этого указателя (адрес памяти). Однако, если вы передадите объект типа `char*` или `const char*`, то `std::cout` предположит, что вы намереваетесь вывести строку. Следовательно, вместо вывода значения указателя — выведется строка, на которую тот указывает:
```cpp
int nArray[5] = { 9, 7, 5, 3, 1 };
char cArray[] = "Hello!";
const char *name = "John";
 
std::cout << nArray << '\n'; 	// nArray распадается в указатель типа int -> 0046FAE8 (адрес)
std::cout << cArray << '\n'; 	/* cArray распадается в указатель типа char -> Hello! (распадается, а потом
автоматически преобразует указатель назад в строку */
std::cout << name << '\n'; 	// name уже и так является указателем типа char -> John
```
В связи с этим сложно вывести адрес переменой типа char:
```cpp
char a = 'R';
std::cout << &a;	// a распадется в указатель, а потом все равно автоматически преобразуется назад.
/* выведет: R╠╠╠╠╜╡4;¿■A (т.е. литерал R, а потом мусор следующий за нем в памяти до ближайшего 0 */
```

## files
Для работы с файлами нужна библиотке `<fstream >`. 
```cpp
# include <string >
# include <fstream >
using namespace std;
int main() 
{
    string name;
    ifstream input("input.txt");
    input >> name;
    ofstream output("output.txt");
    output << "Hi , " << name << endl;
    return 0;
}
```
Создается объект input (типа `std::ifstream`) и иницализируется файлом "input.txt". Далее input ведет себя аналогично потоку std::cin. Те строка `input >> name;` просто записывает содержимое файла в строку name (как это сделал бы std::cin). Далее создается объект output (типа `std::ofstream`) и иницализируется файлом "output.txt". Теперь тут все аналогично действиями оператора std::cout, то теперь все записывает в файл, а не в терминал. Файл закроется, когда закороется ф-ция (и дулится объект output).
