# Chapter 6 Class
## Struct (a public class)
Essentially, it is a class but less secure, since:
1. Members of a class are private by default and members of a struct are public by default.
2. When deriving a struct from a class/struct (inherit), default access-specifier for a base class/struct is public. And when deriving a class, default access specifier is private.    

**Используйте ключевое слово struct для структур, используемых только для хранения данных. Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.**   

Как и любой другой тип данных его можно передавать ф-йии и возвращать.     
```cpp
struct Person{                                 // initialisation of a struct
    string name;                               // these are publicly accessible
    string lastname;			       // переменные структур - поля структур
    int age;
/* Можно делать default присвоение. Их надо ставить в конце, чтобы при инициализации их не переписать, оставив
объявленные без данных. Для них не работает uniform инициализация (способ 3) */
//    double salary = 4000;
};

vector<Person> staff;                          //create vector of Person(s)
staff.push_back({"Ivan","Ivanov", 24});       //initialisation of a instance of Person
staff.push_back({"Petr","Petrov", 100});
cout << staff[0].name;                         //prints "Ivan". Calling a variable of a stuct
```
### Присвоение значений полям
```cpp
Person vasya;			// создаем example vasya структуры person
/* 1й способ: объявляем и присваиваем значение каждому полю вручную */
vasya.name = 'Vasya';                            
vasya.lastname = 'Pupkin';			       
vasya.age = 32;

/* 2й способ: инициализация структуры с параметрами */
struct Employee
{
    short id;
    int age;
    float salary = 0.0;
};

Person john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james = { 6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 3й способ:  инициализацию uniform (C++ 11 и выше) */
Person john { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james { 6, 29 }; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 4й способ: объявили, а потом присвоили используя список инициализаторов (С++ 11 и выше)*/
Person john;
john = { 5, 27, 45000.0 }; // {} - это список инициализаторов
```
### Вложенные структуры 
```cpp
struct Employee
{
    short id;
    int age;
    float salary;
};
 
struct Company
{
    Employee CEO; 				// Employee является структурой внутри структуры Company 
    int numberOfEmployees;
};
 
Company myCompany = {{ 3, 35, 55000.0f }, 7 };  // Инициализация {{stuct Employee}, numberOfEmployees}

myCompany.CEO.salary 				// Обращение к вложенной структуре
```
### Размер   
Обычно это сумма размеров его полей + несколько байт, которые добавляет компилятор для своей внутренней работы. 

**Хотя структуры ведут себя подобно классам (в C++, не в C), за исключением дефолтного спецификатора доступа, рекомендуется использовать их только в случаии, если нужно сгрупировать простые данные под одним логическим признаком (например, серию из переменных int). Если нужны методы и более сложная архитектура, то надо использовать классы. 

---
## Классы
### Анатомия класса
**Спецификатор доступа** определяет, кто имеет доступ к членам этого спецификатора. Eсть 3 уровня доступа:
- `public:` делает члены открытыми
- `private:` делает члены закрытыми
- `protected:` открывает доступ к членам только для дружественных и дочерних классов    
По умолчанию у классов спецификатор private, а у структур public. *Контроль доступа работает на основе класса, а не на основе конкретного экземпляра*. Это означает, что когда метод имеет доступ к закрытыми членам класса, то он может обращаться к закрытым членам любого объекта этого класса:
```cpp
class DateClass // члены класса являются закрытыми по умолчанию 
{
	int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
public:
	void copyFrom(const DateClass &b)
	{
		// Мы имеем прямой доступ к закрытым членам объекта b
		m_day = b.m_day;
		m_month = b.m_month;
		m_year = b.m_year;
	}
}

int main()
{
DateClass date;
date.setDate(12, 11, 2018); // ок, так как setDate() имеет спецификатор доступа public
	
DateClass copy;
copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
/* была создана копия экземпляра date и сохранена в copy */
}
```
**Функция доступа (Access functions)** 
Это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. Функции доступа обычно бывают двух типов:
- **Геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса. Рекомендуется держать их константными `const`.   
- **Сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.

**Память**. Классы, структуры, энумераторы - это тип данных, поэтому при объявлении типа данных не выделятеся память (подобно тому, что память не выделяется встроеным типам данных, например, int). Память выделится при объявлении экземпляра этого класса. Компилятор даже не создает никакого кода, при объявлении класса. Те когда создается экземпляр, компилятор "подглядывает" в это объявление, выделяет память и создает нужную структуру. Однако, в том месте, где программист написал объявление класса, там в ассеблероном листинге ничего не будет.


### Объявление методов вне класса
Парадигма разделения класса на часть, где он объявляется (.h файл) и где реализуется (.cpp файл), позволяет реализовать методы класса вне блока его объявления. В примере ниже прототипы методов `copyFrom` и `ShowDate` должны быть объявлены внутры класса, а реализация может быть вне (как внутри файла, так и в другом файле. Например, объявление класса и все прототипы в .h, а реализации в .cpp:
```cpp
class DateClass 
{
	int m_day;  
	int m_month;  
	int m_year;  
public:
	void copyFrom(const DateClass &b);	/* метод должен быть объявлен внутри класса,
	void ShowDate();			но реализация его лежит за его пределами */
}

// Может быть в том же файле, а может быть в .cpp (если объявление класса в .h)
void DateClass::copyFrom(const DateClass &b)	/* реализация метода за пределами класса; можно в том же файле, 
{						а можно разделить объявление в .h и реализацию в .cpp */
	m_day = b.m_day;
	m_month = b.m_month;
	m_year = b.m_year;
}
void DateClass::ShowDate()			// важно указать принадлежность к классу через оператор ::
{ 
	std::cout << m_day <<'/'<< m_month <<'/'<< m_year;
}
```

### Конструктор
**Конструктор** — это особый тип метода класса, который автоматически вызывается при создании объекта этого класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определённый файл или базу данных). В отличие от обычных методов, конструкторы имеют определённые правила по поводу их имён: 
1. Конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры).
2. Конструкторы не имеют типа возврата (даже void-а).   
```cpp
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    Fraction() // конструктор по умолчанию (default constructor)
    {
         m_numerator = 0;
         m_denominator = 1;
    }
 
    // Конструктор с двумя параметрами, один параметр имеет значение по умолчанию
    Fraction(int numerator, int denominator=1)
    {
        assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
    }
 }
Fraction empty; // вызов Fraction(0, 1) - конструктора по умолчанию
Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)
Fraction seven(7); // вызывается конструктор Fraction(int, int), второй параметр использует значение по умолчанию
```
В примере выше **конструктор по умолчанию (default constructor)**, который будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который будет вызываться, если мы предоставим значения. Эти два конструктора могут мирно существовать в одном классе благодаря перегрузке функций. Фактически, вы можете определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры (учитывается их количество и тип). Однако в этом случаи проще использовать один конструктор с параметрами по-умолчанию: `Fraction(int numerator=0, int denominator=1)`.
```cpp
 Fraction(int numerator=0, int denominator=1)
{
	assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
}
// любая из инициализаций сработает соответствующим образом
Fraction drob; // вызов Fraction(0, 1)
Fraction seven(7); // вызов Fraction(7, 1)
Fraction sixTwo(6, 2); // вызов Fraction(6, 2)
```
Если ваш класс не имеет других конструкторов, то C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют **неявным конструктором (implicitly generated constructor)**.
```cpp
// что пишем и видим мы
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
};
// что видит компилятор
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
 
public:
    Date() // implicitly generated constructor
    {
    }
};
```

#### Default constructors
Начиная с C++ 11, для дефолтных конструторов введен специальный синтаксис: `Somthing() = default;`.   
Существует разница между дефолтным конструктором сделаным так: 1) `Somthing() {}` и так 2) `Somthing() = default;`. Оба конструктора являются дефолтными и будут вызваны, если при создании экземпляра классу ничего не передается. Однако, будет разное поведение. В первом случаи просто выделяется место в памяти под экземпляр и ничего больше не делается. Во втором случаи, выделится место для экщемпляра и конструктор проинициализирует переменные нулями. Например,
```cpp
class A 
{
public:
    int y;
    A(){}
};

class B 
{
public:
    int y;
    B()=default;
};


int main() 
{ 
    int x = 5;
    
    new(&x)A(); 	// (1) Call for empty constructor, which does nothing
    cout << x << endl; 	// 5
    
    new(&x)B; 		// (2) Call for default constructor
    cout << x << endl; 	// 5
    
    new(&x)B(); 	// (3) Call for default constructor + Value initialization (0)
    cout << x << endl; 	// 0
    
    new(&x)A(); 	// (4) Call for empty constructor, which does nothing
    cout << x << endl;	// 0
    return 0; 
} 
```
В примере выше есть класс с конструктором типа 1) (класс А) и типа 2) (класс В). Конструкция `new(&x)A()` требует, что экземпляр был создан именно по адресу, где хранится перемнная x. Таким образом вызов (1) - просто создает класс A по адресу, где была переменная x. Тк это "плохой" (тип 1) дефолтный конструктор, то он не инициализирует y, поэтому y теперь имеет значение оставшееся от x (т.е. 5). Аналогично происходит и в случаях (2) и (4). В случаии (3) вызывается "хороший" дефотный конструктор (тип 2). Он инициализирует y нулем. Теперь по адресу y находится ноль. Поэтому "плохой" конструктор опять просто запишет y (класса A) поверх y (класса B).      
 
#### Конструкторы от одного параметра
Конструкторы от одного параметра могут задать неявное преобразование, которое с первого взгляда может не иметь смысла. В примере ниже запись (не особенно имеет смысл) `Segment s3 = 20` неявно преобразуется в корректную запись для инициализации `Segment s3(20)`:
```cpp
//конструктор класса Poit принимает либо два значения (a, b), либо ни одного, тогда по дефолту (0,0)
class Segment 
{
	Segment() {}
	Segment( double length)
		: p2(length , 0)	//p1 {0,0}, p2 {length, 0}
	{}
	Point p1;	/* Если конструктор Segment вызван без параметров, то p1 {0,0} и p2 {0,0} */
	Point p2;
};

Segment s1;		// Конструктор без параметров ("Segment()") -> p1 {0,0} и p2 {0,0
Segment s2(10);		// Конструктор с параметром ("Segment( double length)") -> p1 {0,0}, p2 {10, 0}
Segment s3 = 20;	/* НЕЯВНОЕ преобразование: "Segment s3 = 20" рассматривается как "Segment s3(20)", 
			это вызывает конструктор с параметром ("Segment( double length)") -> p1 {0,0}, p2 {20, 0} */
```
Аналогично компилятор неявно преобразует и конструктор, который имеет значения по-умполчанию, если ему необходимо передать только одну переменную. Например,
```cpp
//конструктор класса Poit принимает либо два значения (a, b), либо ни одного, тогда по дефолту (0,0)
class Primer 
{
	Primer(double a, double b =0, double c = 1)
	{
		m_a = a;
		m_b = b;
		m_c = c;
	}
};

Primer s1(10);		// m_a = 10; (по-умолчанию) m_b = 0, m_c = 1
Primer s2 = 20;		/* НЕЯВНОЕ преобразование: "Primer s2 = 20" рассматривается как "Primer s(20)",
			 m_a = 20; (по-умолчанию) m_b = 0, m_c = 1 */
```
Чтобы избежать/запретить такое преобразование нужно использовать ключевое слово `explicit` перед конструктором: 
```cpp
struct Segment {
	Segment() {}
	explicit Segment( double length)
		: p2(length , 0)
	{}
	Point p1;
	Point p2;
};

Segment s1;
Segment s2(10);
Segment s3 = 20; // ошибка компиляции
```

#### Список инициализации членов класса
Члены класса могут быть определены присвоением при создании класса (внутри конструктора и, с C++11, внутри тела класса):
```cpp
class Values
{
private:
    int m_value1;
    char m_value3 = 'd';  // можно использовать дефолтную инициализацию.
 
public:
    Values()
    {
        // Это всё операции присваивания, а не инициализация
	// m_value3 будет использовать дефолтную инициализацию
        m_value1 = 3;	// присвоение с помощью конструктора
    }
};
```
Хотя это работает для простых переменных, это не лучший способ это делать тк тут все объекты объявляются, а потом идет присвоение. Таким способом нельзя создать ссылки и константные переменные, тк они должны быть инициализированы (а присвоить им ничего нельзя). Грамотно это делать через **список инициализации**, тогда это будет инициализация всех объектов. В нем, после оператора (`:`) идет инициализация членов класса (не обязательно всех):

```cpp
#include <iostream>

class Values
{
private:
	int m_value1;
	double m_value2;
	char m_value3;

public:
	Values() : m_value1(10), m_value2(11.5), m_value3('a') // напрямую инициализируем переменные-члены класса
	{
		// Нет необходимости использовать присваивание
	}

	Values(int value1, double value2, char value3 = 'd')
		: m_value1(value1), m_value2(value2), m_value3(value3) // напрямую инициализируем переменные-члены класса
	{
	}

	void print()
	{
		std::cout << "Values(" << m_value1 << ", " << m_value2 << ", " << m_value3 << ")\n";
	}

};

int main()
{
	Values valueOne;	 // value1 = 10, value2 = 11.5, value3 = 'a' (все - дефолтная инициализация)
	Values valueTwo(3, 4.5); // value1 = 3, value2 = 4.5, value3 = 'd' (значение по умолчанию)
	valueOne.print();
	valueTwo.print();
	return 0;
}
```
Тут используются два альтернативных конструктора: 1) дефолтный конструктор. У него в списке инициализации прописаны все данные для инициализаци. 2) Конструктор требующий данные для инициплизации (и одно значение берется по умолчанию). Если создается экземпляр класса без данных для инициализации, то вызывается первый конструктор, если есть, то вызывается второй.     

**Инициализация константы**    
Так как инициализация констат происходит при создании нового экземпляра, то возможны все три вида инициализции внизу:
```cpp
class Values
{
private:
    const int m_value1 = 11.;	//1. инициализовали прям на месте (дефолтная)
    const int m_value2;		
    const int m_value3;
 
public:
    Values(): m_value2(7),	//2. инициализация константы при вызове конструктора
    {
    } 
    
    //3. алтернативынй конструктор, который инициализирует все константы полученым значением. А у  m_value3 есть дефолтное значение
    Values(int value1, int value2, int value3 = '444')
		: m_value1(value1), m_value2(value2), m_value3(value3)
    {
    }
};
```

**Инициализация массива**    
```cpp
class Values
{
private:
    const int m_array_zero[10]; 	//const можно инициализировать не только тут, но и в списке инициализваторов
    int m_array[7];
 
public:
    Values(): m_array { 3, 4, 5, 6, 7, 8, 9 },	// используем uniform инициализацию для инициализации массива.
	      m_array {}			// А так обнуляем массив m_array {} 
    {
    } 
};
```

**Инициализация всего подряд**     
Еще пример. Тут инициализируется все в перемешку: переменные класса, подклассы, классы из подключенных библиотек и тд.:
```cpp
// Ниже снипет из главного игрового класса для игры змейка. Один экмепляр на всю игру
Game::Game( MainWindow& wnd )	// Конструктор принимает (по ссылке) экмепляр wnd класса MainWindow 
	:		 // символ того, что это список инициализации 
	m_value1(3), 	 // инициализация переменной типа int из класса Game (из прошлого примера)
	m_value3('d'),	 // инициализация переменной типа char из класса Game(из прошлого примера)
	brd (gfx),	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
	snek({ 20,20 }), /* инициализация экземпляра класса Snake (Snake snek) вложенного в класс Game 
			  при этом вызывается конструктор класса Snake и принимает два int параметра */
	rng(std::random_device()()), /* инициализация экземпляра класса std :: mt19337 (std :: mt19337 rng - ГСЧ), в
				     ложенного в класс Game. При этом конструктор rnd принимает объект 
				     std::random_device()(), который объявлен внутри класса Game по дефолту */
	double m_value2(2.71)	     /* инициализация переменной типа double из класса Game 
				     все инициализации разделены запятой, последняя инициализация без нее */
{
	/* Тут посшло тело конструктора. Здесть можно что-нибудь присвоить или написать нужный код, 
	который будет исполнен разово при объявлении/инициализации экземпляра класса */
	
	std::uniform_int_distribution<int> xDist(2, brd.getWidth());
	std::uniform_int_distribution<int> yDist(2, brd.getHeight());
	
	x_value4 = 3; 	// Это уже операции присваивания, а не инициализация
        x_value5 = 4.5;	
}
```
Такое объявление гораздо удобнее т.к. это все инициализация, поэтому так можно 1) инициализовать подклассы. При инциализации подкласса вызывается его конструктор. При присвоении конструктор не вызовется. 2) Можно инициализцировать const переменные класса, а присваивать им ничего нельзя.   

**Важно!** Порядок инициализации устанавливается не в списке инициализации (не в конструкторе), а при объявлении объектов внутри класса (обычно в .h файле класса).

#### Дефолтная инициализация
Приведенный выше пример можно было инициализировать по дефолту внутри тела класса (хотя и это не очень решение). Ниже приведены два идентичных способа инициализации: 1) списком инициализации, 2) просто инициализацией переменной по дефолту. Оба способа дают идентичный результат. Однако, конструктор (и соответственно список) имеет приоритет, поэтому если конструктор требует инициализирует какие-то значения, то они будут переписаны. 
```cpp
class Game{
public:
	// 1й способ: список инициализации
	Game( MainWindow& wnd )	// Конструктор принимает (по ссылке) экмепляр wnd класса MainWindow 
		:		 // символ того, что это список инициализации 
		m_value1(3), 	 // инициализация переменной класса Game типа int (из прошлого примера)
		const m_value3('d'),	 // инициализация переменной класса Game типа char (из прошлого примера)
		brd (gfx),	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
		snek({ 20,20 }),
		// и так далее ...

private:
	// 2й способ инициализациия переменных по дефолту
	// этот код - избыточен, тк конструктор имеет приоритет
	int m_value1 = 3;
	const char m_value3 = 'd'';
	Board brd = {gfx};	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
	Snake snek = { 20,20 }; 
	// и так далее ...
}
```

#### Делегирующие конструкторы
Бываеют случаи, когда у альтернативных конструкторов совпадают части кода. Например (совпадает "Часть кода X"), 
```cpp
class Boo
{
public:
    Boo()
    {
        // Часть кода X
    }
 
    Boo(int value)
    {
        // Часть кода X
        // Часть кода Y
    }
};
```
В этом случаи есть два подхода:
1. Сделать метод инициализации (`void Init()`). Тогда любой класс сможет вызывать ее, и это позволит избежать повторяющегося кода. Желательно держать этот метод в `private`, чтобы соблюсти инкапсуляцию. Однако, если нужен механизм, который отбрасывает экземпляр к дефолтным значениям, то можно сунуть его в `public`:
```cpp
class Boo
{
private:
    void Init()
    {
        // Код инициализации Boo
    }
    
public:
    Boo()
    {
        Init();
    }
 
    Boo(int value)
    {
        Init();
        // Делаем что-либо с value
    }
/* делать так, только если нужен механизм сброса экзепляра к дефолтному значению
    void Init()
    {
        // Код инициализации Boo
    }
*/
};
```

2. **Делегирующие конструкторы** (C++ 11 и старше)
Это мезанизм позволяющий конструктору вызвать свою альтернативу, используя списки инициализации:
```cpp
class Boo
{
private:
 
public:
    Boo()
    {
        // Часть кода X
    }
 
    Boo(int value): Boo() // используем конструктор по умолчанию Boo() для выполнения части кода X
    {
        // Часть кода Y
    }
 
};
```
Важно, что конструктору, который вызывает другой конструктор, не разрешается выполнять какую-либо инициализацию членов класса. Поэтому конструкторы могут либо вызывать другие конструкторы, либо выполнять инициализацию, но не всё сразу.     
Вот еще пример,
```cpp
#include <iostream> 
#include <string>
 
class Employee
{
private:
    int m_id;
    std::string m_name;
 
public:
    Employee(int id=0, const std::string &name=""):
        m_id(id), m_name(name)
    {
        std::cout << "Employee " << m_name << " created.\n";
    }
 
    // Используем делегирующие конструкторы для сокращения дублированного кода
    Employee(const std::string &name) : Employee(0, name) { }
};
 
int main()
{
    Employee a; 
    Employee b("Ivan");
 
    return 0;
}
```

### Вложенные enum
```cpp
enum FruitList
{
	AVOCADO,
	BLACKBERRY,
	LEMON
};
 
class Fruit
{
private:
	FruitList m_type;
public:
 	Fruit(FruitList type) :
		m_type(type)
	{
	}
 
	FruitList getType() { return m_type;  }
};
 
int main()
{
	Fruit avocado(AVOCADO);
	
	if (avocado.getType() == AVOCADO)
		std::cout << "I am an avocado!";
	else
		std::cout << "I am not an avocado!";
	
	return 0;
}
```
Надо отметить, что следующие обращение к enum из данного класса будут эквивалентны: `Fruit::FruitList::AVOCADO` и `Fruit::AVOCADO`. Однако в случаи вложенных классов надо указавать полный путь пространств: `Snake::Segment::Somthing`.

### Вложенные классы
Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. *Это произойдёт до того, как тело конструктора выполнится*. 

#### Scopes вложенных классов   
Хотя сам любой экземпляр класса обладает доступом ко всем его объектам, экзепляр не будет иметь доступа к объектам  вложенного класса (если он private). Например, 
```cpp
class Snake
{
public:
	// some Snakes fucntions 
private:
	class Segment
	{
	public:
		char get_color(); 	// getter for colors
		int get_loc(); 		// getter for loc
		// some Segment variables
	private:
		char color;
		int loc;
	};

	int nSegments = 4; 
	int segColorCounter = 1;
	Segment snake[nSegmentsMax];
};
```
В этом случаии любой экземпляр `Segment` имеет доступ к `color` и `loc`, однако `Snake` не имеет к ним доступа (для этого ему потребуется использовать `get_color()` и `get_loc()`). Таким образом, тот факт, что `Segment` является объектом внутри класса `Snake`, это не дает `Snake` права на доступ к внутренностям класса `Segment`. Экземпляры `Snake` имеют доступ только к своим объектам, но не их внутренностям. 

### Деструктор 
Когда объект автоматически выходит из **области видимости** или **динамически выделенный** объект явно удаляется с помощью ключевого слова `delete`, вызывается деструктор класса (если он существует) для выполнения необходимой очистки до того, как объект будет удалён из памяти. Для простых классов (тех, которые только инициализируют значения обычных переменных-членов) деструктор не нужен, так как C++ автоматически выполнит очистку самостоятельно.    
Однако, если объект класса содержит любые ресурсы (например, динамически выделенную память или файл/базу данных), или, если вам необходимо выполнить какие-либо действия до того, как объект будет уничтожен, деструктор является идеальным решением, поскольку он последнее, что происходит с объектом перед его окончательным уничтожением. Не смотит забывать, что если для завершения программы используется `exit()`, то деструктор не будт вызван и прогрмма завершится без сохранения данных.

- Деструктор должен иметь то же имя, что и класс, со знаком тильда (`~`) в самом начале.
- Деструктор не может принимать аргументы. Деструктор не имеет типа возврата. Это значит, что деструктор может быть только один.

**Идиома RAII** (англ. «Resource Acquisition Is Initialization» = «Получение ресурсов есть инициализация»)  — это идиома объектно-ориентированного программирования, при которой использование ресурсов привязывается к времени жизни объектов с автоматической продолжительностью. В C++ идиома RAII реализуется через классы с конструкторами и деструкторами. Ресурс (например: память, файл или база данных) обычно приобретается в конструкторе объекта (хотя этот ресурс может быть получен и после создания объекта, если в этом есть смысл). Затем этот ресурс можно использовать, пока объект жив. Ресурс освобождается в деструкторе при уничтожении объекта. Основным преимуществом RAII является то, что это помогает предотвратить утечку ресурсов (например, память, которая не была освобождена), так как все объекты, содержащие ресурсы, автоматически очищаются.    

**Пример ниже соответсвует идиоме RAII**, тк выделение и вызвращение динамической памяти происходит внутри класса. Такии образом нет опасности утечки памяти. 

```cpp
#include <iostream>
#include <cassert>

class Massiv
{
private:
	int *m_array;
	int m_length;
 
public:
	Massiv(int length) // конструктор
	{
		assert(length > 0);
 
		m_array = new int[length];
		m_length = length;
	}
 
	~Massiv() // деструктор
	{
		// Динамически удаляем массив, который выделили ранее
		delete[] m_array ;
	}
 
	void setValue(int index, int value) { m_array[index] = value; }
	int getValue(int index) { return m_array[index]; }
 
	int getLength() { return m_length; }
};
 
int main()
{
	Massiv arr(15); // выделяем 15 целочисленных значений
	for (int count=0; count < 15; ++count)
		arr.setValue(count, count+1);
 
	std::cout << "The value of element 7 is " << arr.getValue(7);
 
	return 0;
} // Объект arr удаляется здесь, поэтому деструктор ~Massiv() вызывается тоже здесь
```

**Пример ниже НЕ соответсвует идиоме RAII**, так тут память выделяется и возвращается вне класса, и значит, программист обязан позаботиться об этом сам:
```cpp
class Another
{
private:
    int m_nID;
 
public:
    Another(int nID)
    {
        std::cout << "Constructing Another " << nID << '\n';
        m_nID = nID;
    }
 
    ~Another()
    {
        std::cout << "Destructing Another " << m_nID << '\n';
    }
 
    int getID() { return m_nID; }
};
 
int main()
{
    // Выделяем объект класса Another из стека
    Another object(1);
    std::cout << object.getID() << '\n';
 
    			// Выделяем объект класса Another динамически из кучи
    Another *pObject = new Another(2);
    std::cout << pObject->getID() << '\n';
    delete pObject;	// Возвращаем память в кучу. Вызывается деструктор для pObject 
 
    return 0;
} // Объект object выходит из области видимости здесь. Вызывается деструктор для object
```

### Скрытый указатель *this ->

#### Что такое ->
Это синтаксис обозначающий обращение к полю экземпляра, если экземпляр представлен указателем. Те `a->b` означает: если указатель на некоторый экзепляр класса (`ptr_a = &a`) и у этого класса поле (`b`). Тогда, чтобы обратиться к полю `b` экзепляра `a`, на который указывает `ptr_a`, надо его разыменовать, а потом обратиться к полю через опретор точка (`.`): `(*ptr_a).b`. Для этого придумали короткую запись: `a->b`.    

#### *this 
Любой метод класса работает аналогично обычным ф-циям. Главное отличие это то, что компилятор неявно (скрыто) подставляет туда указать на экземпляр, который вызвал этот метод. Например, ниже идет простой пример класса с геттером и сеттером.
```cpp
/* Это пишем и видем мы */
class Another
{
private:
    int m_number;
 
public:
    Another(int number)	
    {
        setNumber(number);
    }
 
    void setNumber(int number) { m_number = number; }	//обычный сеттер
    int getNumber() { return m_number; }		//обычный геттер
};
 
int main()
{
    Another another(3);		//объявили класса, инициализовали m_number = 3
    another.setNumber(4);	//присвоили m_number = 4
    std::cout << another.getNumber() << '\n';	//выведет "4"
 
    return 0;
}
```
А так компилятор видет методы этого класса:
```cpp
// весто "void setNumber(int number) { m_number = number; }"
void setNumber(Another* const this, int number) { this->m_number = number; }
// весто "int getNumber() { return this->m_number; }"
    int getNumber(Another* const this) { return this->m_number; }
};
 
int main()
{
    Another another(3);		//объявили класса, инициализовали m_number = 3
    setNumber(&another, 4); 	/* Вместо  "another.setNumber(4)". Объект another конвертировался из объекта, 								который находился перед точкой, в аргумент функции! */ 
    std::cout << getNumber(&another) << '\n';	//вместо "another.getNumber()"
 
    return 0;
}
```
- Все методы видятся компилятору как вызовы обычных ф-ций, куда неявно передали ссылку на экземпляр класса, который вызвал этот метод: ` another.setNumber(4);` -> `setNumber(&another, 4)`. Более того, при объявлении ф-ции компилятор неявно добавляет в аргументы константный указатель на этот экземпляр (`Another* const this`). Указатель `*this` — это **скрытый константный указатель**, что содержит адрес объекта, который вызывает метод класса.   
- К любым переменным-членам внутри setNumber() добавляется префикс `this->`. Поэтому, когда мы говорим `m_number = number`, компилятор фактически выполняет `this->m_number = number`. 

#### *this всегда указывает на текущий объект
Каждый метод имеет в качестве параметра указатель *this, который указывает на адрес объекта с которым в данный момент выполняется операция.
```cpp
int main()
{
    Another X(3); // *this = &X внутри конструктора Another
    Another Y(4); // *this = &Y внутри конструктора Another
    X.setNumber(5); // *this = &X внутри метода setNumber
    Y.setNumber(6); // *this = &Y внутри метода setNumber
}
```
 Указатель *this поочерёдно содержит адрес объектов X или Y в зависимости от того, какой метод вызван и сейчас выполняется.
 
 #### Когда использовать *this
Все описанные выше вещи с `*this` происходят "под капотом" неявно. Однако есть два случая, когда `*this` используется явно:

1. **Чтобы избежать конфлик имен в классе**. Когда локальная переменная/переданная имеет такое же имя, что и поле поле класса:
	```cpp
	class Something
	{
	private:
	    int data;			//это поле класса Something

	public:
	    Something(int data)  	//а тут - это передаваемая в ф-цию локальаня переменная
	    {
		this->data = data;	//а тут был бы конфлик имен, если бы не *this
	    }
	};
	```
2. **Цепочки методов класса**. Метод получает возможность возвращать указатель на этот экземпляр (`*this`), чтобы следующий метод мог быть вызван "последовательно" через оператор точка (`.`). Ниже идет простой класса, который имеет три метода (add, sub, multiply). Они возвращают void, и поэтому, чтобы провести действия над экземпляром operation, нужно вызывать их каждую по отдельности:
	```cpp
	class Mathem
	{
	private:
	    int m_value;

	public:
	    Mathem() { m_value = 0; }

	    void add(int value) { m_value += value; }
	    void sub(int value) { m_value -= value; }
	    void multiply(int value) { m_value *= value; }

	    int getValue() { return m_value; }
	};

	int main()
	{
	    Mathem operation;
	    operation.add(7); 		// возвращает void
	    operation.sub(5); 		// возвращает void
	    operation.multiply(3); 	// возвращает void

	    std::cout << operation.getValue() << '\n';
	    return 0;
	}
	```
	Однако, если каждая функция будет возвращать `*this`, то мы сможем связать эти вызовы методов в одну цепочку. Перепишем пример сверху:
	```cpp
	class Mathem
	{
	private:
	    int m_value;

	public:
	    Mathem() { m_value = 0; }

	    Mathem& add(int value) { m_value += value; return *this; }		//возвращает указатель на этот экземепляр
	    Mathem& sub(int value) { m_value -= value; return *this; }		//возвращает указатель на этот экземепляр
	    Mathem& multiply(int value) { m_value *= value; return *this; }	//возвращает указатель на этот экземепляр

	    int getValue() { return m_value; }
	};

	int main()
	{
	    Mathem operation;
	    operation.add(7).sub(5).multiply(3);	//это позволяет использовать точку для последовательного вызова методов

	    std::cout << operation.getValue() << '\n';
	    return 0;
	}
	```
	
	**std::cout <<** - это и есть цепочка вызовов методов. А точнее оператор `<<` действует на `std::cout` и возвращает указатель на 	тот же`std::cout`:    
	`std::cout << "Hello, " << userName;` можно представить как `(std::cout << "Hello, ") << userName;`. После операции вывода 		строки Hello, оператор `<<` возвращает объект, на который он был вызван (те `std::cout`) назад: `(std::cout) << userName;`. И 		так далее, пока не кончится поток.

###  Const методы
**Константный метод** — это метод, который гарантирует, что *не будет изменять объект* или *вызывать неконстантные методы класса* (поскольку они могут изменить объект). Для того, чтобы определить метод как константный нужно добавить в конце `const`:
```cpp
class Anything
{
public:
    int m_value;
 
    Anything() { m_value= 0; }
 
    void resetValue() { m_value = 0; }
    void setValue(int value) { m_value = value; }
 
    int getValue() const; 	// обратите внимание на ключевое слово const здесь
};
 
int Anything::getValue() const 	// и здесь. Оно должно быть и в объявлении прототипа, и в реализации
{
    return m_value;
}

int main()
{
    const Anything anything; // вызываем конструктор по умолчанию
 
    anything.m_value = 7; 	// ошибка компиляции: нарушение const
    anything.setValue(7); 	// ошибка компиляции: нарушение const
    anything.getValue();	// ОК, тк это конст метод
 
    return 0;
}
```
В примере выше, мы создали константный экземпляр класса. В этом случаии, если мы будем вызывать какие-либо неконстантные методы класса (например, `setValue`) или попытаемся менять поля напрямую через оператор точка (`.`), то это вызовет ошибку компиляции. Если константный метод что-то изменяет в вызываемом объекте, то это вызовет ошибку компиляции.     

Также, если константный метод вызывает неконтсантную метод/ф-цию (даже если те ничего не меняют), то это вызовет ошибку компиляции. Например, для того же случая что и вышел (`const Anything anything` - константный экземпляр):
```cpp
class Anything
{
public:
	int m_value;
	Anything() { m_value = 0; }	// конструктор
	
	int regetValue();		// не const метод
	int getValue() const; 		// const метод
};

int Anything::regetValue()		/* ничего не меняет, просто возвращает значение
{					 Однако, его нельзя использовать для const объектов и/или
	return m_value;			 внутри const методов */
}

int Anything::getValue() const 		/* компилятор выдаст ошибку тк const метод вызывает не const метод
{					 насмотря на то, что этот метод ничего не пробует менять */
	return regetValue();
}
```
Ошибка, которую выдвет компилятор в этом случаи, звучит так: `'int Anything::regetValue(void)': cannot convert 'this' pointer from 'const Anything' to 'Anything &'`. Те метод `regetValue` хочет получить сслыку на обычный экземпляр (те `this`), а тут ему передают `const this` (с которым работает метод `getValue`), а конвертация одного в другого невожможна.

#### mutable
Если переменная объявлена как `mutable`, то ее можно изменять внутри константных методов: `mutable int a;`

#### Константные ссылки и классы
Аналогичная проблема возникнет, если передавать в ф-цию const ссылку, а внутри вызывать неконстантные ф-ции (даже если они ничего не меняют), тк проблема не в изменении, а в том, что ф-ции ожидают опреденные (в данных случаях разные) виды данных:
```cpp
class Date
{
private:
    int m_day;
    int m_month;
    int m_year;
 
public:
    Date(int day, int month, int year)
    {
        setDate(day, month, year);
    }
 
    void setDate(int day, int month, int year)
    {
        m_day = day;
        m_month = month;
        m_year = year;
    }
 
    int getDay() { return m_day; }
    int getMonth() { return m_month; }
    int getYear() { return m_year; }
};
 
// Примечание: Мы передаём объект date по константной ссылке, дабы избежать создания копии объекта date
void printDate(const Date &date)
{//Однако, геттеры данного класса не константные, а значит возникнет конфликт описанный выше и компилятор выдаст ошибку
    std::cout << date.getDay() << "." << date.getMonth() << "." << date.getYear() << '\n';
}
 
int main()
{
    Date date(12, 11, 2018);
    printDate(date);		/* независимая от класса ф-ция просто хочет, чтобы ей передали объект по константной ссылке,
    				 но внутри она хочет использовать его же методы, которые не константы. Это вызовет ошибку */ 
    return 0;
}
```

#### Перегрузка константных и неконстантных функций
Хотя это делается не очень часто, но функцию можно перегрузить таким образом, чтобы иметь константную и неконстантную версии одной и той же функции. Константная версия функции будет вызываться для константных объектов, а неконстантная версия будет вызываться для неконстантных объектов.
```cpp
class Anything
{
private:
    std::string m_value;
public:
    Anything(const std::string &value="") { m_value= value; }
 
    const std::string& getValue() const { return m_value; } // getValue() для константных объектов
    std::string& getValue() { return m_value; } // getValue() для неконстантных объектов
};

int main()
{
	Anything anything;
	anything.getValue() = "Hello!"; // ОК, вызывается неконстантный getValue()
 
	const Anything anything2;
	anything2.getValue(); 		// ОК, вызывается константный getValue()
 
	return 0;
}
```

------

## Static 
### Static переменные класса
В отличие от обычных переменных-членов, статические переменные-члены являются *общими для всех экеземпляров* класса. Более того, статические члены существуют, даже если объекты класса не созданы! Подобно глобальным переменным, *они создаются при запуске программы и уничтожаются, когда программа завершает своё выполнение*. 
```cpp
class Anything
{
public:
    static int s_value;
};
 
int Anything::s_value = 3;
 
int main()
{
    Anything first;
    Anything second;
 
    first.s_value = 4;
 
    std::cout << first.s_value << '\n';	// оба экземпляра имеют доступ к static value
    std::cout << second.s_value << '\n';
    return 0;
}
```

- Поскольку статические переменные-члены не являются частью отдельных объектов класса (они обрабатываются аналогично глобальным переменным и инициализируются при запуске программы), то вы должны явно определить статический член вне тела класса: в глобальной области видимости. Если класс определён в заголовочном файле, то определение статического члена обычно помещается в файл с кодом класса (например, в Anything.cpp). Если класс определён в файле .cpp, то определение статического члена обычно пишется непосредственно под классом:
```cpp
class Anything
{
public:
    static int s_value;	// объявляем статическую переменную-член
};
 
int Anything::s_value = 3; // определяем статическую переменную-член
 
int main()
{
    // Примечание: Мы не создаём здесь никаких объектов класса Anything
    Anything::s_value = 4;
    std::cout << Anything::s_value << '\n';	//выведет "4"
    return 0;
}
```

- Есть несколько обходных путей определения статических членов внутри тела класса. Во-первых, если статический член является константным интегральным типом (к которому относятся и char, и bool) или константным перечислением, то статический член может быть инициализирован внутри тела класса. Также с C++11 статические члены constexpr любого типа данных, поддерживающие инициализацию `constexpr`, могут быть инициализированы внутри тела класса:
```cpp
class Anything
{
public:
     static const int s_value = 5; // статическую константную переменную типа int можно объявить и инициализировать напрямую
    
     static constexpr double s_value = 3.4; // хорошо
     static constexpr std::array<int, 3> s_array = { 3, 4, 5 }; // это даже работает с классами, 													// которые поддерживают инициализацию constexpr
};
```
 
- Можно определить статическую переменную-член, даже если она является private.
```cpp
class IDGenerator
{
private:
    static int s_nextID; // объявление статической переменной-члена
};

int IDGenerator::s_nextID = 1; // все ОК

int main()
{s_nextID
	std::cout << IDGenerator::s_nextID; // ERROR! Тут private уже не позволит получить доступ к s_nextID
	return 0;
}
```

#### Static методы
Подобно статическим переменным-членам, статические методы не привязаны к какому-либо одному объекту класса. Те их можно вызывать не черех экземпляр, а непосредственно через классовое пространство имен (`::`):
```cpp
class Anything
{
private:
    static int s_value;
public:
    static int getValue() { return s_value; } // статический метод
};
 
int Anything::s_value = 3; // определение статической переменной-члена класса
 
int main()
{
    std::cout << Anything::getValue() << '\n';
}
```
- Поскольку статические методы не привязаны к объекту, то они не имеют скрытого указателя `*this`! Здесь есть смысл, так как указатель `*this` всегда указывает на экземпляр, с которым работает метод. Статические методы могут не работать через экземпляр, поэтому и указатель `*this` не имеет смысла.
- Статические методы могут напрямую обращаться к другим статическим членам (переменным или функциям), но не могут к нестатическим членам. Это связано с тем, что нестатические члены принадлежат объекту класса, а статические методы — нет!

## friend (дружественные класса и ф-ции)
**Дружественная функция** — это функция, которая имеет доступ к закрытым членам класса, как если бы она сама была членом этого класса. Во всех других отношениях дружественная функция является обычной функцией. Ею может быть как обычная функция, так и метод другого класса. Для объявления дружественной функции используется ключевое слово `friend` перед прототипом функции, которую вы хотите сделать дружественной классу. Неважно, объявляете ли вы её в public или в private зоне класса. 
```cpp
class Anything
{
private:
    int m_value;
public:
    Anything() { m_value = 0; } 
    void add(int value) { m_value += value; }
 
    // Делаем функцию reset() дружественной классу Anything
    friend void reset(Anything &anything);
};
 
// reset() теперь является другом класса Anything
void reset(Anything &anything)
{
    // И мы имеем доступ к закрытым членам объектов класса Anything
    anything.m_value = 0;
}
 
int main()
{
    Anything one;
    one.add(4); // добавляем 4 к m_value
    reset(one); // сбрасываем m_value к 0
 
    return 0;
}
```

### Дружественные функции и несколько классов
Функция может быть другом сразу для нескольких классов. Например,
```cpp
class Humidity; 
 
class Temperature
{
private:
    int m_temp;
public:
    Temperature(int temp=0) { m_temp = temp; }
 
    friend void outWeather(const Temperature &temperature, const Humidity &humidity);
};
 
class Humidity
{
private:
    int m_humidity;
public:
    Humidity(int humidity=0) { m_humidity = humidity; }
 
    friend void outWeather(const Temperature &temperature, const Humidity &humidity);
};
 
void outWeather(const Temperature &temperature, const Humidity &humidity)
{
    std::cout << "The temperature is " << temperature.m_temp <<
       " and the humidity is " << humidity.m_humidity << '\n';
}
 
int main()
{
    Temperature temp(15);
    Humidity hum(11);
 
    outWeather(temp, hum);
 
    return 0;
}
```
Тут надо отметить, что важно внчале указать прототип класса идущего не первым (тут `class Humidity;`) тк при первом упоминании ф-ции в первом классе компилятор зайдет в нее и увидет, что там ссылаются на необъявленный класс. Он будет недоволен.

### Дружественные классы
Один класс можно сделать дружественным другому классу. Это откроет всем членам первого класса доступ к закрытым членам второго класса. Например, 
```cpp
class Values
{
private:
    int m_intValue;
    double m_dValue;
public:
    Values(int intValue, double dValue)
    {
        m_intValue = intValue;
        m_dValue = dValue;
    }
 
    // Делаем класс Display другом класса Values
    friend class Display;
};
 
class Display
{
private:
    bool m_displayIntFirst;
 
public:
    Display(bool displayIntFirst) { m_displayIntFirst = displayIntFirst; }
 
    void displayItem(Values &value)
    {
        if (m_displayIntFirst)
            std::cout << value.m_intValue << " " << value.m_dValue << '\n';
        else // или сначала выводим double
            std::cout << value.m_dValue << " " << value.m_intValue << '\n';
    }
};
 
int main()
{
    Values value(7, 8.4);
    Display display(false);
 
    display.displayItem(value);
 
    return 0;
}
```
На самом деле, даже если Display является другом Values, это не означает, что Values также является другом Display. Если вы хотите сделать оба класса дружественными, то каждый из них должен указать в качестве друга противоположный класс. Наконец, если класс A является другом B, а B является другом C, то это не означает, что A является другом C.    

#### Дружественные методы (вместо целого класса)
Вообще делать классы дружественными - это плохая идея (ломает всю инкапсуляцию). Если все же надо, что какой-то из методов одного класса мог добраться до закрытых методов другого класса, то лучше использовать дружественные методы.  Лучшим решением было бы поместить каждое определение класса в отдельный заголовочный файл с определениями методов в соответствующих файлах .cpp. Таким образом, все определения классов стали бы видны сразу во всех файлах .cpp. В этом случаии объявление будет аналогичным примеру сверху, только вместо `friend class Display;` будет `friend void Display::displayItem(Values& value);` (те только нужный нам метод).


## void * или история про злого близница
Существует такая уезвимость у закрытых членов классов/структур: доступ к ним можно получить через злого близница.   
Допустим, есть такой класс: 
```cpp
class Cls{

public:
	Cls() = default;
private:
	char c = 'a';
    	double d = 3.14;
	int i = 101;
};
```
Все его члены (c, d, i) закрыты а мы хотим получить к ним доступ используя ф-ции вида: `char& get_c(Cls& cls)` те в нее передается экщемпляр класса по ссылке и возвращается ссылка на этот элемент. Чтобы это сделать, нам нужно сделать подставного "злого брата-близница", который будет более сговорчив:
```cpp
class Cls_bro {

public:
	Cls_bro() = default;
	char c;			//Он более сговорчив
	double d;		//делаем нужные нам поля открытыми 
	int i;
};
```
Теперь идет хитрость внутри ф-ции `get_c`. В нее мы будем передавать экземпляр класса `Cls`, но она должна думать, что работает с классом `Cls_bro`. Хитрость в том, что когда происходит насильственное преобразование типов (`static_cast`) из чего-то в указатель на void, то компилятор забывает, чем переменная была до этого. Поэтому преобразование типа `const int` -> `any_type` невозможны (компилятор сравнивает их и говорит, что такое преобразование невозможно), а `const int` -> `void *` -> `any_type` возможны (компилятор не помни, что было до `void *`). Итого, целиком код выглядит так:
```cpp
class Cls{

public:
	Cls() = default;
	char getter()
	{
		return c;
	}
private:
	char c = 'a';
    double d;
	int i;
};

class Cls_bra {

public:
	Cls_bra() = default;
	char c;
	double d;
	int i;
};

char& get_c(Cls& cls) {

	void* ptr = static_cast<void*>(&cls);
	Cls_bra* cls_ptr = static_cast<Cls_bra*>(ptr);
	return cls_ptr->c;
}

// аналогично можно написать ф-ции доступа и к другим полям
```
