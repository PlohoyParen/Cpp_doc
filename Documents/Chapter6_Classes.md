# Chapter 6 Class
## Struct (a public class)
Essentially, it is a class but less secure, since:
1. Members of a class are private by default and members of a struct are public by default.
2. When deriving a struct from a class/struct (inherit), default access-specifier for a base class/struct is public. And when deriving a class, default access specifier is private.    

**Используйте ключевое слово struct для структур, используемых только для хранения данных. Используйте ключевое слово class для объектов, объединяющих как данные, так и функции.**   

Как и любой другой тип данных его можно передавать ф-йии и возвращать.     
### Синтаксис  
```cpp
struct Person{                                 // initialisation of a struct
    string name;                               // these are publicly accessible
    string lastname;			       // переменные структур - поля структур
    int age;
/* Можно делать default присвоение. Их надо ставить в конце, чтобы при инициализации их не переписать, оставив
объявленные без данных. Для них не работает uniform инициализация (способ 3) */
//    double salary = 4000;
    
}
vector<Person> staff;                          //create vector of Person(s)
staff.push_badck({"Ivan","Ivanov", 24});       //initialisation of a instance of Person
staff.push_badck({"Petr","Petrov", 100});
cout << staff[0].name;                         //prints "Ivan". Calling a variable of a stuct
```
#### Присвоение значений полям
```cpp
Person vasya;			// создаем example vasya структуры person
/* 1й способ: объявляем и присваиваем значение каждому полю вручную */
vasya.name = 'Vasya';                            
vasya.lastname = 'Pupkin';			       
vasya.age = 32;

/* 2й способ: инициализация структуры с параметрами */
Person john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james = { 6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 3й способ:  инициализацию uniform (C++ 11 и выше) */
Person john { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
Person james { 6, 29 }; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

/* 4й способ: объявили, а потом присвоили используя список инициализаторов (С++ 11 и выше)*/
Person john;
john = { 5, 27, 45000.0 }; // {} - это список инициализаторов
```
#### Вложенные структуры 
```cpp
struct Employee
{
    short id;
    int age;
    float salary;
};
 
struct Company
{
    Employee CEO; 				// Employee является структурой внутри структуры Company 
    int numberOfEmployees;
};
 
Company myCompany = {{ 3, 35, 55000.0f }, 7 };  // Инициализация {{stuct Employee}, numberOfEmployees}

myCompany.CEO.salary 				// Обращение к вложенной структуре
```
### Размер   
Обычно это сумма размеров его полей + несколько байт, которые добавляет компилятор для своей внутренней работы. 

---
## Классы
### Анатомия класса
**Спецификатор доступа** определяет, кто имеет доступ к членам этого спецификатора. Eсть 3 уровня доступа:
- `public:` делает члены открытыми
- `private:` делает члены закрытыми
- `protected:` открывает доступ к членам только для дружественных и дочерних классов    
По умолчанию у классов спецификатор private, а у структур public. *Контроль доступа работает на основе класса, а не на основе объекта*. Это означает, что когда метод имеет доступ к закрытыми членам класса, то он может обращаться к закрытым членам любого объекта этого класса:
```cpp
class DateClass // члены класса являются закрытыми по умолчанию 
{
	int m_day; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_month; // закрыто по умолчанию, доступ имеют только другие члены класса
	int m_year; // закрыто по умолчанию, доступ имеют только другие члены класса
public:
	void copyFrom(const DateClass &b)
	{
		// Мы имеем прямой доступ к закрытым членам объекта b
		m_day = b.m_day;
		m_month = b.m_month;
		m_year = b.m_year;
	}
}

int main()
{
DateClass date;
date.setDate(12, 11, 2018); // ок, так как setDate() имеет спецификатор доступа public
	
DateClass copy;
copy.copyFrom(date); // ок, так как copyFrom() имеет спецификатор доступа public
/* была создана копия экземпляра date и сохранена в copy */
}
```
**Функция доступа (Access functions)** 
Это короткая открытая функция, задачей которой является получение или изменение значения закрытой переменной-члена класса. Функции доступа обычно бывают двух типов:
- **Геттеры** — это функции, которые возвращают значения закрытых переменных-членов класса.
- **Сеттеры** — это функции, которые позволяют присваивать значения закрытым переменным-членам класса.

**Память**. Классы, структуры, энумераторы - это тип данных, поэтому при объявлении типа данных не выделятеся память (подобно тому, что память не выделяется встроеным типам данных, например, int). Память выделится при объявлении экземпляра этого класса. 


### Конструктор
**Конструктор** — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определённый файл или базу данных). В отличие от обычных методов, конструкторы имеют определённые правила по поводу их имён: 
1. Конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры).
2. Конструкторы не имеют типа возврата (даже void-а).   
```cpp
class Fraction
{
private:
    int m_numerator;
    int m_denominator;
 
public:
    Fraction() // конструктор по умолчанию (default constructor)
    {
         m_numerator = 0;
         m_denominator = 1;
    }
 
    // Конструктор с двумя параметрами, один параметр имеет значение по умолчанию
    Fraction(int numerator, int denominator=1)
    {
        assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
    }
 }
Fraction empty; // вызов Fraction(0, 1) - конструктора по умолчанию
Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)
Fraction seven(7); // вызывается конструктор Fraction(int, int), второй параметр использует значение по умолчанию
```
В примере выше **конструктор по умолчанию (default constructor)**, который будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который будет вызываться, если мы предоставим значения. Эти два конструктора могут мирно существовать в одном классе благодаря перегрузке функций. Фактически, вы можете определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры (учитывается их количество и тип). Однако в этом случаи проще использовать один конструктор с параметрами по-умолчанию: `Fraction(int numerator=0, int denominator=1)`.
```cpp
 Fraction(int numerator=0, int denominator=1)
{
	assert(denominator != 0);
        m_numerator = numerator;
        m_denominator = denominator;
}
// любая из инициализаций сработает соответствующим образом
Fraction drob; // вызов Fraction(0, 1)
Fraction seven(7); // вызов Fraction(7, 1)
Fraction sixTwo(6, 2); // вызов Fraction(6, 2)
```
Если ваш класс не имеет других конструкторов, то C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют **неявным конструктором (implicitly generated constructor)**.
```cpp
// что пишем и видим мы
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
};
// что видит компилятор
class Date
{
private:
    int m_year = 1900;
    int m_month = 1;
    int m_day = 1;
 
public:
    Date() // implicitly generated constructor
    {
    }
};
```

#### Список инициализации членов класса
Члены класса могут быть определены присвоением при создании класса (внутри конструктора и, с C++11, внутри тела класса):
```cpp
class Values
{
private:
    int m_value1;
    char m_value3 = 'd';  // присваивание в теле класса (с С++11)
 
public:
    Values()
    {
        // Это всё операции присваивания, а не инициализация
        m_value1 = 3;	// присвоение с помощью конструктора
    }
};
```
Хотя это работает для простых переменных, это не лучший способ это делать тк тут все объекты объявляются, а потом идет присвоение. Грамотно это делать через **список инициализации**, тогда это будет инициализация всех объектов. В нем, после оператора (`:`) идет инициализация членов класса (не обяхательно всех):
```cpp
// Ниже снипет из иглавного игрового класса для игры змейка. Один экмепляр на всю игру
Game::Game( MainWindow& wnd )	// Конструктор принимает (по ссылке) экмепляр wnd класса MainWindow 
	:		 // символ того, что это список инициализации 
	m_value1(3), 	 // инициализация переменной класса Game типа int (из прошлого примера)
	m_value3('d'),	 // инициализация переменной класса Game типа char (из прошлого примера)
	brd (gfx),	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
	snek({ 20,20 }), /* инициализация экземпляра класса Snake (Snake snek) вложенного в класс Game 
	при этом конструктор класса Snake принимает два int параметра */
	rng(std::random_device()()), /* инициализация экземпляра класса std :: mt19337 (std :: mt19337 rng - ГСЧ), в
	ложенного в класс Game. При этом конструктор rnd принимает объект std::random_device()(), который
	объявлен внутри класса Game по дефолту */
	double m_value2(2.71)	// инициализация переменной класса Game типа double
	// все инициализации разделены запятой, последняя инициализация без нее
{
	// Тут посшло тело конструктора. Здесть можно что-нибудь присвоить или написать нужный код, 
	который будет исполнен разово при объявлении/инициализации экземпляра класса
	
	std::uniform_int_distribution<int> xDist(2, brd.getWidth());
	std::uniform_int_distribution<int> yDist(2, brd.getHeight());
	
	x_value4 = 3; 	// Это уже операции присваивания, а не инициализация
        x_value5 = 4.5;	
}
```
Такое объявление гораздо удобнее т.к. это все инициализация, поэтому так можно 1) инициализовать подклассы. При инциализации подкласса вызывается его конструктор. При присвоении конструктор не вызовется. 2) Можно инициализцировать const переменные класса, а присваивать им ничего нельзя.   

**Важно!** Порядок инициализации устанавливается не в списке инициализации (не в конструкторе), а при объявлении объектов внутри класса (обычно в .h файле класса).

#### Дефолтная инициализация
Приведенный выыше пример можно было инициализировать по дефолту внутри тела класса (хотя и это не очень решение). Ниже приведены два идентичных способа инициализации: 1) списком инициализации, 2) просто инициализацией переменной по дефолту. Оба способа дают идентичный результат. Однако, конструктор (и соответственно список) имеет приоритет, поэтому если конструктор требует инициализирует какие-то значения, то они будут переписаны. 
```cpp
class Game{
public:
	// 1й способ: список инициализации
	Game( MainWindow& wnd )	// Конструктор принимает (по ссылке) экмепляр wnd класса MainWindow 
		:		 // символ того, что это список инициализации 
		m_value1(3), 	 // инициализация переменной класса Game типа int (из прошлого примера)
		const m_value3('d'),	 // инициализация переменной класса Game типа char (из прошлого примера)
		brd (gfx),	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
		snek({ 20,20 }),
		// и так далее ...

private:
	// 2й способ инициализациия переменных по дефолту
	// этот код - избыточен, тк конструктор имеет приоритет
	int m_value1 = 3;
	const char m_value3 = 'd'';
	Board brd = {gfx};	 // инициализация экземпляра класса Board (Board brd) вложенного в класс Game 
	Snake snek = { 20,20 }; 
	// и так далее ...
}
```

### Вложенные классы
Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. *Это произойдёт до того, как тело конструктора выполнится*. 

#### Scopes вложенных классов   
Хотя сам любой экземпляр класса обладает доступом ко всем его объектам, экзепляр не будет иметь доступа к объектам  вложенного класса (если он private). Например, 
```cpp
class Snake
{
public:
	// some Snakes fucntions 
private:
	class Segment
	{
	public:
		char get_color(); 	// getter for colors
		int get_loc(); 		// getter for loc
		// some Segment variables
	private:
		char color;
		int loc;
	};

	int nSegments = 4; 
	int segColorCounter = 1;
	Segment snake[nSegmentsMax];
};
```
В этом случаии любой экземпляр `Segment` имеет доступ к `color` и `loc`, однако `Snake` не имеет к ним доступа (для этого ему потребуется использовать `get_color()` и `get_loc()`). Таким образом, тот факт, что `Segment` является объектом внутри класса `Snake`, это не дает `Snake` права на доступ к внутренностям класса `Segment`. Экземпляры `Snake` имеют доступ только к своим объектам, но не их внутренностям. 
