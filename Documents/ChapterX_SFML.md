# Chapter X SFML
**SFML** (с англ. «Simple and Fast Multimedia Library» = «Простая и быстрая мультимедийная библиотека») - свободная кроссплатформенная мультимедийная библиотека, написанная на C++, но также доступна и для C, C#, .Net, D, Java, Python, Ruby, OCaml, Go и Rust. Представляет собой объектно-ориентированный аналог SDL. На ней можно писать 2D графические приложения.
## Создание проекта и добавление зависемостей
Подробнее [тут](https://ravesli.com/graficheskaya-biblioteka-sfml-vstuplenie-i-ustanovka/). Последовательность действий:
1. подключить каталог заголовочных и исходных файлов SFML (/include);
2. подключить каталог библиотечных файлов SFML (/lib);
3. подключить библиотечные файлы SFML в качестве дополнительных зависимостей;
4. скопировать .dll файлы в проект.

## Скилет программы
```cpp
#include <SFML/Graphics.hpp>

using namespace sf;

int main()
{
	// Объект, который, собственно, является главным окном приложения
	RenderWindow window(VideoMode(1200, 600), "SFML Works!");
	// Главный цикл приложения. Выполняется, пока открыто окно
	while (window.isOpen())
	{
		// Обрабатываем очередь событий в цикле
		Event event;
		while (window.pollEvent(event))
		{
			// Пользователь нажал на «крестик» и хочет закрыть окно?
			if (event.type == Event::Closed)
				// Тогда закрываем его
				window.close();
		}
		window.clear(Color(250, 220, 100, 0));
		// Отрисовка окна	
		window.display();
	}

	return 0;
}
```
- `RenderWindow window(VideoMode(1200, 600), "SFML Works!");` - окно выводимое на экран - это объект класса RenderWindow. Тут `VideoMode(1200, 600)` - класс задающий размеры окна, `"SFML Works!"` - название окна. Все взаимодействия в с окном производятся над объектом  window. Например, `window.display();` - вызывает отрисовку окна. `window.close();` - закрытие окна.
- `window.clear(Color(250, 220, 100, 0));` - заливка окна цветом заданным объектом Color. `(Color(R, G, B, alpha));` - цвет задается через RGB и aplha (уровень прозрачности).
- `while (window.isOpen()){...}` - главный loop. Тут обрабатываются все действия между последовательными отрисовками. 
- `while (window.pollEvent(event))` - loop обработки событий. Он последовательно "вытягивает" event из очериди событий. `pollEvent(event)` - "вытягивание" события. `event.type == Event::Closed` - если нажали на крестик, то это событие ::Closed.

*Примечание:* ф-ция `window.display();` идет последней тк она отображает конечный вариант фрейма. Если мы хотим нарисовать что-то в окне это все должно быть до window.display(). Например, мы рисуем круг:
```cpp
CircleShape circle(50.f); // Создаём фигуру: круг радиусом 50
circle.setFillColor(Color(230, 0, 230)); // Закрашиваем накруг 
window.draw(circle); // <- добавляем объект в данный фрейм перед отрисовкой		
// Отрисовка окна
window.display();
```

## Простые фигуры 
### Круги и многоугольники (CircleShape)
Для рисования кругов используется класса `CircleShape`. Его конструктор принимает диаметр и кол-во углов у фигуры (по дефолту 30, тк при 30 угралах фигура малотличима от круга). С помощью этого класса можно нарисовать любую симетричную фигуру.
```cpp
// Создаём круг радиусом 50
CircleShape circle(50.f);	//по дефолту кол-во углов = 30, что соответствует кругу
circle.setFillColor(Color(230, 0, 230)); // закрашиваем наш круг. Можно добавить 4й параметр Color - прозрачность
circle.setOutlineThickness(15.f); // устанавливаем толщину контура круга
circle.setOutlineColor(Color(80,220,50)); // устанавливаем цвет контура
circle.move(15, 15); // перемещаем наш круг для корректного отображения в окне
window.draw(circle); // отрисовка круга	
// Создаём треугольник
CircleShape triangle(65.f, 3);
triangle.setPosition(125, 0); // устанавливаем начальную позицию справа от круга
triangle.setFillColor(Color::Blue); // устанавливаем цвет треугольника - синий
window.draw(triangle); // отрисовка треугольника
// Создаём квадрат
CircleShape square(60.f, 4);
square.setPosition(250, 0); // устанавливаем начальную позицию справа от треугольника
square.setFillColor(Color::Red); // устанавливаем цвет квадрата - красный
window.draw(square); // отрисовка квадрата
// Создаём октагон
CircleShape octagon(60.f, 8);
octagon.setPosition(380, 0); // устанавливаем начальную позицию справа от квадрата
octagon.setFillColor(Color::Cyan); // устанавливаем цвет октагона - бирюзовый
window.draw(octagon); // отрисовка октагона
```
### Выпуклые многоугольники (ConvexShape)
Нарисоварить многоугольник можно с помощью класса `ConvexShape`. Объекту этого класса надо задать кол-во точек используя метод `.setPointCount(int n)`, а затем задать положение в окне `.setPoint(0, Vector2f(0.f, 0.f))`: 1е число - это номер точки, координаты вершин задаются в виде контейнера `Vector2f(a, b)`. Данный контейнер — это простой шаблонный класс библиотеки SFML. 
```cpp
ConvexShape convex;
// Устанавливаем ему 5 вершин
convex.setPointCount(5);
// Устанавливаем координаты вершин
convex.setPoint(0, Vector2f(0.f, 0.f));
convex.setPoint(1, Vector2f(150.f, 10.f));
convex.setPoint(2, Vector2f(120.f, 90.f));
convex.setPoint(3, Vector2f(30.f, 100.f));
convex.setPoint(4, Vector2f(5.f, 50.f));

convex.setFillColor(Color::Black); // Устанавливаем цвет многоугольника - чёрный
convex.move(1, 150); // Теперь сдвинем его вниз и чуть-чуть вправо
 
window.draw(convex); // Отрисовка многоугольника
```
*Примечание:* Порядок, в котором вы будете определять точки многоугольника, очень важен. Все они должны быть определены либо по часовой стрелке, либо против часовой стрелки. Если вы будете определять их в несогласованном порядке, то форма многоугольника будет построена неправильно.

### Прямоугольник (RectangleShape)
Для рисования прямоугольников используется класс `RectangleShape`, конструктор которого принимает ширину и высоту (в формате Vector2f(a, b). 
```cpp
RectangleShape rectangle(Vector2f(70.f, 100.f));
rectangle.move(165, 150); // Перемещаем его в нижний ряд справа от многоугольника
rectangle.setFillColor(Color(175, 180, 240)); // Устанавливаем ему цвет
line_with_thickness.rotate(45.f); // Поворачиваем её на 45 градусов
```

### Сглаживание 
Нет возможности сделать сглаживание для отдельной фигуры. Сглаживание осуществляется для все всех фигур одновременно.
```cpp
// Устанавливаем 8-ой уровень сглаживания
ContextSettings settings;
settings.antialiasingLevel = 8;
```
## Текстуры и спрайты
- `Texture` - класс для текстур. Его основные задачи - это 1) загрузка текстуры в программу и 2)"натягивание" текстуры на спрайт.
- `Sprite` - класс для спрайтов.      
```cpp
Texture texture; // Объявляем переменную текстуры
texture.loadFromFile("path"); // Подгружаем нашу текстуру из файла 
Sprite sprite(texture); // Создаём спрайт и устанавливаем ему нашу текстуру
window.draw(sprite); // Отрисовка спрайта
```

При загрузке текстуры можно загрузить лишь часть изображения. Например, следующий код загружает небольшой кусочек текстуры размером 32×32 пикселя, начинающийся с координат (10;10): 
```cpp
texture.loadFromFile("image.png", IntRect(10, 10, 32, 32));
```   

Спрайт можно сгладить используя метод  `texture.setSmooth(true)`. В этом случаи  не бут видно "острых" пикселей, но текстура может стать мыльной (чем больше спрайт, тем сильнее заметно).
