# Chapter 15: Inheritance
## Общее
В C++ логика наследования потроена на принципе "является", те пусть есть класс Hunman(имеет age, name) и класса Employee (имеет age, name, id, salary). В этом случаии логично сделать Employee подклассом Human (те Employee является Human, тк у них совпадают поля age, name). Реализовывается это так: `ChildClassName :access_specifier ParetClassName` (`access_specifier`: `public`, `private` или `proteсted`) Например,
```cpp
class Human
{/*опустим его тело*/}

class Employee: public Human    //Employee наследует от класса Human (со спецификатором public)
{/*опустим его тело*/}
```

## Порядок построения дочерних классов
При наследовании Child класс не копирует поля и методы Parent класса. Вместо этого можно рассматривайь Child как класс, который состоит из двух частей: первая — Parent, вторая — Child. При этом у них свои отдельные поля, методы, конструкторы и декструкторы. Пусть, например, у нас есть следующие Parent и Child классы:
```cpp
class Parent
{
public:
    int m_id;                             //поля Parent
 
    Parent(int id=0)                      //констркутор Parent
        : m_id(id)
    {
        std::cout << "Parent\n";
    }
 
    int getId() const { return m_id; }     //методы Parent
};
 
class Child: public Parent                 //Child наследует от Parent
{
public:
    double m_value;                        //поле Child
  
    Child(double value=0.0)                //конструктор Child
        : m_value(value)
    {
        std::cout << "Child\n";
    }
 
    double getValue() const { return m_value; }
};
 
int main()
{
    std::cout << "!!!Instantiating Parent!!!:\n";
    Parent dParent;    // Создаем экземпляр класса Parent 
    
    std::cout << "!!!Instantiating Child!!!:\n";
    Child dChild;      // Создаем экземпляр класса Parent 
 
    return 0;
}

/* Будет выведено *******************************
!!!Instantiating Parent!!!:
Parent
!!!Instantiating Child!!!:
Parent    //те сначала выполнился конструктор Parent
Child     //потом выполнился конструктор Child
************************************************/
```
**Создаем экземпляр класса Parent**      
Что происходит:
1. выделяется память для объекта parent;
2. вызывается соответствующий конструктор класса Parent (если его нет, то компилятор вызовет конструктор по умолчанию);
3. список инициализации инициализирует переменные;
4. выполняется тело конструктора;
5. точка выполнения возвращается обратно в caller.

**Создаем экземпляр класса Child**
Что происходит: 
1. выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта класса Child);
2. вызывается соответствующий конструктор класса Child;
3. создаётся объект класса Parent с использованием соответствующего конструктора класса Parent. Если такой конструктор программистом не предоставлен, то будет использоваться конструктор по умолчанию класса Parent;
4. список инициализации инициализирует переменные;
5. выполняется тело конструктора;
6. точка выполнения возвращается обратно в caller.

### Инициализация членов родительского класса при наследовании
Для членов уникальных для Child класса (не наследованных) все инициализуется как обычно. Однако инициализация членов Parent класса имеет свои особенности: они всегда должны быть инициплизованны через список инициализации *используя конструктор класса Parent* (см. выше: шаг 3 создания экземпляра Child). Если у Parent нет подходящего конструктора, то компилятор сгенерирует сам, однако часто это будет неподходящий конструктор, и лучше самому наперед написать хороший. Ниже представлены три варианта попытки инициализировать члены класса Parent при создании Child (1я правильная, 2я и 3я - неправильно!):    

1. 
    ```cpp
    // 1й пример (ОК!): используя список инициализации и конструктор Parent
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            : Parent(id), // вызывается конструктор Parent(int) со значением id!
                m_value(value)
        {
        }

        double getValue() const { return m_value; }
    };
    ```
    Тут все правильно, но нужно убедиться, что у Parent есть хороший конструктор. C++ запрещает дочерним классам инициализировать наследуемые переменные-члены родительского класса в списке инициализации своего конструктора. Другими словами, **значение переменной может быть задано только в списке инициализации конструктора, принадлежащего к тому же классу, что и переменная-член** (ошибка в примере 2). Тут так же не возникнет проблемы с доступом к членам Parent (они могут и скорее всего будут private), как в примере 3. Таким способом можно и нужно инициализировать члены Parent, как public, так и private.
2. 
    ```cpp
    //2й пример (ОШИБКА!): используя список инициализации и прямую инициализацию члена Parent
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            // Не сработает
            : m_value(value), m_id(id)
        {
        }

        double getValue() const { return m_value; }
    };
    ```
    Как было сказано выше, C++ запрещает инициализировать напрямую члены класса Parent. Для этого надо использовать конструктор. Таким образом не нарушается проблема инициализации private членов Parent класса. Инкапсуляция!

3. 
    ```cpp
    //3й пример (ОШИБКА!): используя тело конструктора
    class Child: public Parent
    {
    public:
        double m_value;

        Child(double value=0.0, int id=0)
            : m_value(value)
        {
            m_id = id;
        }

        double getValue() const { return m_value; }
    };
    ```
    До тела конструктора Child мы доходим уже после вызова конструктора Parent класса и списка инициализации Child (см. шаги выше). Это значит, что m_id уже был создан дефолтным конструктором Parent, а теперь в теле мы пытаемя его инициализировать, но мы не знаем, может он private. Вообще говоря, код скомпилируется, если m_id - public, но будет ошибка, если он private. В любом случаии - это плохой код!

### Цепочка наследований
#### Конструкторы
Пусть у нас есть Parent класса A, от него наследуют B. От B наследует C. В этом случаии цепочка расскручиваестя следующим образом: C вызывает конструктор для B, тот в свою очередь вызывает конструктор для A. 
```cpp
class A
{
public:
    A(int a)
    {
    }
};
 
class B: public A
{
public:
    B(int a, double b)
    : A(a)
    {
    }
};
 
class C: public B
{
public:
    C(int a , double b , char c)
    : B(a, b)
    {
    }
};
```

### Деструкторы
При уничтожении дочернего класса, каждый деструктор вызывается в обратном порядке построения классов: "изнутры-наружу". В примере выше, при уничтожении объекта класса С, сначала вызывается деструктор класса C, затем деструктор класса B, а затем уже деструктор класса A.

## Спецификаторы наследования
### Спецификаторы доступа
Классы имеют 3 вида спецификаторов доступа: public, private и protected (имеет смысл лишь в контексте наследования). **Protected** - это спецификатор, который ведет себя как private (запрещает доступ к челенам и методам извне), однако, когда класс наследуется, то к ним меет доступ Child класс. Еще раз, пусть у нас есть некоторый член в классе Parent (my_field). Если переменная имеет следующий спецификатор доступа, то:
1. `public` - Child имеет доступ к ней. Child также предоставляется к ней доступ извне: `child.my_field`.
2. `private` - Child не имеет доступ к ней. Child не может предоставит к ней доступ извне.
3. `protected` - Child имеет доступ к ней. Однако, Child *не может предоставит к ней доступ извне*.

Например,
```cpp
class Parent
{
public:
    int m_public;           // доступ к этому члену открыт для всех объектов
private:
    int m_private;          // доступ к этому члену открыт только для Parent
protected:
    int m_protected;        // доступ к этому члену открыт для Parent и для дочерних классов (Child)
};
 
class Child: public Parent
{
public:
    Child()
    {
        m_public = 1;       // МОЖНО: доступ к открытым членам родительского класса из дочернего класса
        m_private = 2;      // НЕЛЬЗЯ: доступ к закрытым членам родительского класса из дочернего класса
        m_protected = 3;    // МОЖНО: доступ к защищённым членам родительского класса из дочернего класса
    }
};
 
int main()
{   // При доступе извне дочерних классо
    Parent parent;
    parent.m_public = 1;    // МОЖНО: доступ к открытым членам класса извне
    parent.m_private = 2;   // НЕЛЬЗЯ: доступ к закрытым членам класса извне
    parent.m_protected = 3; // НЕЛЬЗЯ: доступ к защищённым членам класса извне
    
    Child child;
    child.m_public = 4;     // МОЖНО: доступ к открытым членам класса извне
    child.m_private = 5;    // НЕЛЬЗЯ: доступ к закрытым членам класса извне
//  child.m_protected = 6;  // НЕЛЬЗЯ: доступ к защищенным членам класса извне
}
```
### Типы наследований
При этом используются те же 3 типа наследования: public, private и protected. Они могут накладывать свои особенности и Parent спецификаторы доступа.
#### public (открытое наследование)
```cpp
class Child: public Parent // открытое наследование
```
Если Child наследуют открыто, то Parent спецификаторы доступа действуют так же, как обычно (см. выше). 
| Тип члена в Parent | Какой тип этот член имеет в Child |
|:-------------------|:----------------------------------|
| public | public |
| private | недоступен |
| protected | protected |
Те, если Child унаследовал protected член через public наследование, то он так же может передать его следующему классу-наследнику (в цепочке наследования) как protected.
