# Chapter 15: Inheritance
## Общее
В C++ логика наследования потроена на принципе "является", те пусть есть класс Hunman(имеет age, name) и класса Employee (имеет age, name, id, salary). В этом случаии логично сделать Employee подклассом Human (те Employee является Human, тк у них совпадают поля age, name). Реализовывается это так: `ChildClassName :access_specifier ParetClassName` (`access_specifier`: `public`, `private` или `proteсted`) Например,
```cpp
class Human
{/*опустим его тело*/}

class Employee: public Human    //Employee наследует от класса Human (со спецификатором public)
{/*опустим его тело*/}
```

## Порядок построения дочерних классов
При наследовании Child класс не копирует поля и методы Parent класса. Вместо этого можно рассматривайь Child как класс, который состоит из двух частей: первая — Parent, вторая — Child. При этом у них свои отдельные поля, методы, конструкторы и декструкторы. Пусть, например, у нас есть следующие Parent и Child классы:
```cpp
class Parent
{
public:
    int m_id;                             //поля Parent
 
    Parent(int id=0)                      //констркутор Parent
        : m_id(id)
    {
        std::cout << "Parent\n";
    }
 
    int getId() const { return m_id; }     //методы Parent
};
 
class Child: public Parent                 //Child наследует от Parent
{
public:
    double m_value;                        //поле Child
  
    Child(double value=0.0)                //конструктор Child
        : m_value(value)
    {
        std::cout << "Child\n";
    }
 
    double getValue() const { return m_value; }
};
 
int main()
{
    std::cout << "!!!Instantiating Parent!!!:\n";
    Parent dParent;    // Создаем экземпляр класса Parent 
    
    std::cout << "!!!Instantiating Child!!!:\n";
    Child dChild;      // Создаем экземпляр класса Parent 
 
    return 0;
}

/* Будет выведено *******************************
!!!Instantiating Parent!!!:
Parent
!!!Instantiating Child!!!:
Parent    //те сначала выполнился конструктор Parent
Child     //потом выполнился конструктор Child
************************************************/
```
**Создаем экземпляр класса Parent**      
Что происходит:
1. выделяется память для объекта parent;
2. вызывается соответствующий конструктор класса Parent (если его нет, то компилятор вызовет конструктор по умолчанию);
3. список инициализации инициализирует переменные;
4. выполняется тело конструктора;
5. точка выполнения возвращается обратно в caller.

**Создаем экземпляр класса Child**
Что происходит: 
1. выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта класса Child);
2. вызывается соответствующий конструктор класса Child;
3. создаётся объект класса Parent с использованием соответствующего конструктора класса Parent. Если такой конструктор программистом не предоставлен, то будет использоваться конструктор по умолчанию класса Parent;
4. список инициализации инициализирует переменные;
5. выполняется тело конструктора;
6. точка выполнения возвращается обратно в caller.

### Инициализация членов родительского класса при наследовании
Для членов уникальных для Child класса (не наследованных) все инициализуется как обычно. Однако инициализация членов Parent класса имеет свои особенности: они всегда должны быть инициплизованны через список инициализации *используя конструктор класса Parent* (см. выше: шаг 3 создания экземпляра Child). Если у Parent нет подходящего конструктора, то компилятор сгенерирует сам, однако часто это будет неподходящий конструктор, и лучше самому наперед написать хороший. Ниже представлены три варианта попытки инициализировать члены класса Parent при создании Child (1я правильная, 2я и 3я - неправильно!):
```cpp
// 1й пример (ОК!): используя список инициализации и конструктор Parent
class Child: public Parent
{
public:
    double m_value;
 
    Child(double value=0.0, int id=0)
        : Parent(id), // вызывается конструктор Parent(int) со значением id!
            m_value(value)
    {
    }
 
    double getValue() const { return m_value; }
};
```
Тут все правильно, но нужно убедиться, что у Parent есть хороший конструктор. C++ запрещает дочерним классам инициализировать наследуемые переменные-члены родительского класса в списке инициализации своего конструктора. Другими словами, **значение переменной может быть задано только в списке инициализации конструктора, принадлежащего к тому же классу, что и переменная-член** (ошибка в примере 2). Тут так же не возникнет проблемы с доступом к членам Parent (они могут и скорее всего будут private), как в примере 3.

```cpp
//2й пример (ОШИБКА!): используя список инициализации и прямую инициализацию члена Parent
class Child: public Parent
{
public:
    double m_value;
 
    Child(double value=0.0, int id=0)
        // Не сработает
        : m_value(value), m_id(id)
    {
    }
 
    double getValue() const { return m_value; }
};
```
Как было сказано выше, C++ запрещает инициализировать напрямую члены класса Parent. Для этого надо использовать конструктор. Таким образом не нарушается проблема инициализации private членов Parent класса. Инкапсуляция!
```cpp
//3й пример (ОШИБКА!): используя тело конструктора
class Child: public Parent
{
public:
    double m_value;
 
    Child(double value=0.0, int id=0)
        : m_value(value)
    {
        m_id = id;
    }
 
    double getValue() const { return m_value; }
};
```
До тела конструктора Child мы доходим уже после вызова конструктора Parent класса и списка инициализации Child (см. шаги выше). Это значит, что m_id уже был создан дефолтным конструктором Parent, а теперь в теле мы пытаемя его инициализировать, но мы не знаем, может он private. Вообще говоря, код скомпилируется, если m_id - public, но будет ошибка, если он private. В любом случаии - это плохой код!
