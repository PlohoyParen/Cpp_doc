# Chapter 15: Inheritance
## Общее
В C++ логика наследования потроена на принципе "является", те пусть есть класс Hunman(имеет age, name) и класса Employee (имеет age, name, id, salary). В этом случаии логично сделать Employee подклассом Human (те Employee является Human, тк у них совпадают поля age, name). Реализовывается это так: `ChildClassName :access_specifier ParetClassName` (`access_specifier`: `public`, `private` или `proteсted`) Например,
```cpp
class Human
{/*опустим его тело*/}

class Employee: public Human    //Employee наследует от класса Human (со спецификатором public)
{/*опустим его тело*/}
```

## Порядок построения дочерних классов
При наследовании Child класс не копирует поля и методы Parent класса. Вместо этого можно рассматривайь Child как класс, который состоит из двух частей: первая — Parent, вторая — Child. При этом у них свои отдельные поля, методы, конструкторы и декструкторы. Пусть, например, у нас есть следующие Parent и Child классы:
```cpp
class Parent
{
public:
    int m_id;                             //поля Parent
 
    Parent(int id=0)                      //констркутор Parent
        : m_id(id)
    {
        std::cout << "Parent\n";
    }
 
    int getId() const { return m_id; }     //методы Parent
};
 
class Child: public Parent                 //Child наследует от Parent
{
public:
    double m_value;                        //поле Child
  
    Child(double value=0.0)                //конструктор Child
        : m_value(value)
    {
        std::cout << "Child\n";
    }
 
    double getValue() const { return m_value; }
};
 
int main()
{
    std::cout << "!!!Instantiating Parent!!!:\n";
    Parent dParent;    // Создаем экземпляр класса Parent 
    
    std::cout << "!!!Instantiating Child!!!:\n";
    Child dChild;      // Создаем экземпляр класса Parent 
 
    return 0;
}

/* Будет выведено *******************************
!!!Instantiating Parent!!!:
Parent
!!!Instantiating Child!!!:
Parent    //те сначала выполнился конструктор Parent
Child     //потом выполнился конструктор Child
************************************************/
```
**Создаем экземпляр класса Parent**      
Что происходит:
1. выделяется память для объекта parent;
2. вызывается соответствующий конструктор класса Parent (если его нет, то компилятор вызовет конструктор по умолчанию);
3. список инициализации инициализирует переменные;
4. выполняется тело конструктора;
5. точка выполнения возвращается обратно в caller.

**Создаем экземпляр класса Parent**
Что происходит: 
1. выделяется память для объекта дочернего класса (достаточная порция памяти для части Parent и части Child объекта класса Child);
2. вызывается соответствующий конструктор класса Child;
3. создаётся объект класса Parent с использованием соответствующего конструктора класса Parent. Если такой конструктор программистом не предоставлен, то будет использоваться конструктор по умолчанию класса Parent;
4. список инициализации инициализирует переменные;
5. выполняется тело конструктора;
6. точка выполнения возвращается обратно в caller.
